<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="小梦同学的博客">
    <meta name="author" content="小梦同学">
    
    <title>
        
            分布式锁 |
        
        小梦同学的博客
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="/images/logo.svg">
    
    
<link rel="stylesheet" href="/font/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/font/css/regular.min.css">

    
<link rel="stylesheet" href="/font/css/solid.min.css">

    
<link rel="stylesheet" href="/font/css/brands.min.css">

    
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN"}
    KEEP.theme_config = {"toc":{"enable":false,"number":false,"expand_all":false,"init_open":true,"layout":"right"},"style":{"primary_color":"#0066cc","logo":"/images/logo.svg","favicon":"/images/logo.svg","avatar":"/images/avatar.svg","first_screen":{"enable":false,"header_transparent":false,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving.","hitokoto":false},"scroll":{"progress_bar":false,"percent":false}},"local_search":{"enable":false,"preload":false},"code_block":{"tools":{"enable":false,"style":"default"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":false},"lazyload":{"enable":false},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":null,"reaction":false,"version":2},"giscus":{"repo":null,"repo_id":null,"category":"Announcements","category_id":null,"reactions_enabled":false}},"post":{"author_label":{"enable":true,"auto":true,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"wordcount":false,"min2read":false},"copyright_info":false},"website_count":{"busuanzi_count":{"enable":false,"site_uv":false,"site_pv":false,"page_pv":false}},"version":"3.7.3"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container border-box">

    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left border-box">
            
                <a class="logo-image border-box" href="/">
                    <img src="/images/logo.svg">
                </a>
            
            <a class="site-name border-box" href="/">
               小梦同学的博客
            </a>
        </div>

        <div class="right border-box">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">

                

                    <div class="fade-in-down-animation">
    <div class="post-page-container border-box">

        <div class="article-content-container border-box">

            <div class="article-title">
                <span class="title-hover-animation">分布式锁</span>
            </div>

            
                <div class="article-header border-box">
                    
                        <div class="avatar-box border-box">
                            <img src="/images/avatar.svg">
                        </div>
                    
                    <div class="info-box">
                        <div class="author">
                            <span class="name">小梦同学</span>
                            
                                <span class="author-label">Lv1</span>
                            
                        </div>
                        <div class="meta-info border-box">
                            

<div class="article-meta-info-container border-box post">
    <div class="article-meta-info border-box">
        


        
            <span class="meta-info-item article-create-date">
                <i class="icon fa-solid fa-calendar-check"></i>&nbsp;
                <span class="pc">2023-07-01 11:37:07</span>
                <span class="mobile">2023-07-01 11:37</span>
            </span>

            <span class="meta-info-item article-update-date">
                <i class="icon fa-solid fa-file-pen"></i>&nbsp;
                <span class="pc">2023-07-01 11:37:07</span>
            </span>
        

        
            <span class="meta-info-item article-category border-box"><i class="icon fas fa-folder"></i>&nbsp;
                <ul>
                    
                </ul>
            </span>
        

        
            <span class="article-tag meta-info-item border-box">
                <i class="icon fas fa-tags"></i>&nbsp;
                <ul>
                    
                </ul>
            </span>
        

        
        
        
        
    </div>

    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content keep-markdown-body">
                

                <h2 id="1-传统锁-减库存案例"><a href="#1-传统锁-减库存案例" class="headerlink" title="1. 传统锁 - 减库存案例"></a>1. 传统锁 - 减库存案例</h2><p><a target="_blank" rel="noopener" href="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/stock.png"><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/stock.png" alt="img"></a></p>
<p>多线程同时操纵同一个服务的共享资源，必然会造成线程安全问题。</p>
<p>解决方案：采用JVM提供的 <code>Reentrantlock</code> 或者 <code>Synchronized</code> 锁</p>
<h3 id="1-1-初始化工程"><a href="#1-1-初始化工程" class="headerlink" title="1.1 初始化工程"></a>1.1 初始化工程</h3><p>这一部分跟着视频完成，以下内容省略了未连接数据库之前的部分（个人认为之前未连接数据库的部分仅演示了并发流程，与实际业务关联性不大，也较为容易，可自行实现）。</p>
<ol>
<li><p>创建SpringBoot工程，选择 <code>JDK8</code> 版本，引入 <code>Spring Web</code></p>
</li>
<li><p>在 <code>pom.xml</code>引入如下依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.4.3.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.18.24&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">XML</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数据库 <code>distributed_lock</code>，在数据库内创建表 <code>db_stock</code>，创建如下字段。</p>
<p><a target="_blank" rel="noopener" href="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/20221008221626.png"><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/20221008221626.png" alt="img"></a></p>
<p>新建一条数据记录</p>
<p><a target="_blank" rel="noopener" href="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/20221008221728.png"><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/20221008221728.png" alt="img"></a></p>
</li>
<li><p>修改application.properties文件，规定Web启动端口号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server.port=10010</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/distributed_lock</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=your password</span><br><span class="line"></span><br><span class="line">PROPERTIES</span><br></pre></td></tr></table></figure>
</li>
<li><p>在目录下创建 <code>pojo</code> 包，用于存放实体类 <code>Stock</code> 对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@TableName(&quot;db_stock&quot;)</span><br><span class="line">public class Stock &#123;</span><br><span class="line"></span><br><span class="line">private Long id;</span><br><span class="line">private String productCode;</span><br><span class="line">private String warehouse;</span><br><span class="line">private Integer count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>

<p>创建 <code>mapper</code> 包，创建 <code>StockMapper</code> 类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface StockMapper extends BaseMapper&lt;Stock&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>

<p>更改 <code>SpringBoot</code> 启动类，添加如下注解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@MapperScan(&quot;com.ltyzzz.distributedlock.mapper&quot;)</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>

<p>创建 <code>service</code> 包，创建 <code>StockService</code> 类</p>
<p>try-finally块之后用于加锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class StockService &#123;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private StockMapper stockMapper;</span><br><span class="line"></span><br><span class="line">private ReentrantLock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">public void deduct() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Stock stock = this.stockMapper.selectOne(new QueryWrapper&lt;Stock&gt;().eq(&quot;product_code&quot;, &quot;1001&quot;));</span><br><span class="line">        if (stock != null &amp;&amp; stock.getCount() &gt; 0) &#123;</span><br><span class="line">            stock.setCount(stock.getCount() - 1);</span><br><span class="line">            this.stockMapper.updateById(stock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>

<p>创建 <code>controller</code> 包，创建 <code>StockController</code> 类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class StockController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    StockService stockService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;stock/deduct&quot;)</span><br><span class="line">    public String deduct() &#123;</span><br><span class="line">        stockService.deduct();</span><br><span class="line">        return &quot;hello stock deduct!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="1-2-JVM本地锁"><a href="#1-2-JVM本地锁" class="headerlink" title="1.2 JVM本地锁"></a>1.2 JVM本地锁</h3><h4 id="1-2-1-使用JMeter进行并发测试"><a href="#1-2-1-使用JMeter进行并发测试" class="headerlink" title="1.2.1 使用JMeter进行并发测试"></a>1.2.1 使用JMeter进行并发测试</h4><p>首先启动 SpringBoot 库存项目</p>
<p>利用 <code>JMeter</code> 进行压力测试</p>
<ol>
<li><p>创建 <code>Thread Group</code></p>
<p><a target="_blank" rel="noopener" href="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/thread-group.png"><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/thread-group.png" alt="img"></a></p>
</li>
<li><p>设置 <code>Thread Properties</code></p>
<p><a target="_blank" rel="noopener" href="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/thread-proper.png"><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/thread-proper.png" alt="img"></a></p>
</li>
<li><p>设置 <code>request</code></p>
<p><a target="_blank" rel="noopener" href="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/reque.png"><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/reque.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/20221008224501.png"><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/20221008224501.png" alt="img"></a></p>
</li>
<li><p>添加 <code>Aggregate Report</code></p>
<p><a target="_blank" rel="noopener" href="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/20221008224122.png"><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/20221008224122.png" alt="img"></a></p>
</li>
<li><p>运行压力测试，正常执行情况最终库存应该为0</p>
</li>
</ol>
<p>最终数据库结果如下</p>
<p><a target="_blank" rel="noopener" href="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/data%20stcok.png"><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/data%20stcok.png" alt="img"></a></p>
<p>此时产生了并发操作</p>
<p>有两种极限情况</p>
<ul>
<li>所有并发请求都完美的交错执行，正确地完成了数据库更新，最终库存为0</li>
<li>所有并发请求同一时间并发，同时执行了数据库更新操作，并发线程数为100，循环次数为50，最终库存为4950</li>
</ul>
<h4 id="1-2-2-加入JVM本地锁解决并发问题"><a href="#1-2-2-加入JVM本地锁解决并发问题" class="headerlink" title="1.2.2 加入JVM本地锁解决并发问题"></a>1.2.2 加入JVM本地锁解决并发问题</h4><p>修改 <code>StockService</code>。使用 <code>ReentrantLock</code> 或 <code>Synchronized</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class StockService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StockMapper stockMapper;</span><br><span class="line"></span><br><span class="line">    private ReentrantLock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public void deduct() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            Stock stock = this.stockMapper.selectOne(new QueryWrapper&lt;Stock&gt;().eq(&quot;product_code&quot;, &quot;1001&quot;));</span><br><span class="line">            if (stock != null &amp;&amp; stock.getCount() &gt; 0) &#123;</span><br><span class="line">                stock.setCount(stock.getCount() - 1);</span><br><span class="line">                this.stockMapper.updateById(stock);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>

<p>启动 <code>SpringBoot</code> 工程，继续进行压力测试，最终库存为0。</p>
<h4 id="1-2-3-JVM本地锁失效的情况"><a href="#1-2-3-JVM本地锁失效的情况" class="headerlink" title="1.2.3 JVM本地锁失效的情况"></a>1.2.3 JVM本地锁失效的情况</h4><p>共有三种情况</p>
<h5 id="多例模式"><a href="#多例模式" class="headerlink" title="多例模式"></a>多例模式</h5><p>修改 <code>StockService</code>，设置多例模式</p>
<p>添加注解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Scope(value = &quot;prototype&quot;, proxyMode = ScopedProxyMode.TARGET_CLASS)</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>

<p>JDK动态代理使用 <code>INTERFACES</code>，CGLIB代理使用 <code>TARGET_CLASS</code></p>
<p>默认情况下使用JDK动态代理，原生Spring默认是JDK动态代理</p>
<p>而SpringBoot在2.0版本之后默认使用CGLIB代理</p>
<p>启动 <code>SpringBoot</code> 工程，继续进行压力测试，最终库存不为0，说明本地锁失效</p>
<h5 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h5><p>在 <code>service</code> 方法上添加事务注解 <code>@Transactional</code></p>
<p>启动 <code>SpringBoot</code> 工程，继续进行压力测试，最终库存不为0，说明本地锁失效</p>
<p>事务采用AOP思想实现：</p>
<ol>
<li>在AOP的前置方法内开启事务</li>
<li>进入service方法，获取锁</li>
<li>进行查询库存、更新库存操作</li>
<li>释放锁</li>
<li>在AOP的后置方法内提交或回滚事务</li>
</ol>
<p>在并发情况下，如图所示</p>
<p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/tab.png" alt="img"></p>
<p>b用户在a用户还未提交事务之前，就获取到了a用户释放的锁，读取到了库存，但该库存为旧的库存（因为a用户还未提交事务），所以b用户是在旧库存的基础上进行修改，因此产生了并发问题。</p>
<p>解决方案：设置事务隔离级别</p>
<p>将注解改为：<code>@Transactional(isolation = Isolation.READ_UNCOMMITTED)</code></p>
<p>即此时b用户可以读取到a用户未提交的数据，即该数据为最新数据，可以解决此问题。</p>
<p>但实际业务中不能这样去使用，采用事务就是为了保证原子性，要么全部成功，要么全部失败。假设b用户在这种方式下读取到了最新数据，虽然可以解决超卖问题，但是如果a回滚了事务，那么b用户读取到的数据就是错误的，又会产生新的混乱。</p>
<h5 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h5><p>多个服务器部署</p>
<p>去掉 <code>@Transactional</code> 注解，保证在单机模式下锁生效，无并发问题。</p>
<p>这部分看视频做</p>
<ol>
<li><p>设置两个SpringBoot启动类，设置不同的端口号，并启动</p>
</li>
<li><p>更改 <code>nginx</code> 配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upstream distributedLock &#123;</span><br><span class="line">    server localhost:10086;</span><br><span class="line">    server localhost:10010;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://distributedLock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NGINX</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动nginx</p>
</li>
</ol>
<p>任务管理器中出现两个nginx即代表启动成功，一个工作进程，一个主进程</p>
<p>以默认端口80进行访问：<code>localhost:80/stock/deduct</code></p>
<p>之后，使用JMeter进行压力测试，5000个请求成功发出，但最终库存不为0，锁失效。</p>
<h3 id="1-3-单SQL语句解决并发问题"><a href="#1-3-单SQL语句解决并发问题" class="headerlink" title="1.3 单SQL语句解决并发问题"></a>1.3 单SQL语句解决并发问题</h3><h4 id="1-3-1-实现过程"><a href="#1-3-1-实现过程" class="headerlink" title="1.3.1 实现过程"></a>1.3.1 实现过程</h4><p>原 <code>Service</code> 代码流程</p>
<ol>
<li>查询库存</li>
<li>判断库存是否充足</li>
<li>更新库存到数据库</li>
</ol>
<p>该流程可以使用一个SQL语句实现</p>
<p>为 <code>StockMapper</code> 添加方法 updateStock，</p>
<p>参数为商品编号 <code>productCode</code> 与减库存数量<code>count</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface StockMapper extends BaseMapper&lt;Stock&gt; &#123;</span><br><span class="line">    @Update(&quot;update db_stock set count = count - #&#123;count&#125; where product_code = #&#123;productCode&#125; and count &gt;= #&#123;count&#125;&quot;)</span><br><span class="line">    int updateStock(@Param(&quot;productCode&quot;) String productCode, @Param(&quot;count&quot;) Integer count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>

<p>SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update db_stock set count = count - #&#123;count&#125; where product_code = #&#123;productCode&#125; and count &gt;= #&#123;count&#125;</span><br><span class="line"></span><br><span class="line">N1QL</span><br></pre></td></tr></table></figure>

<p>在MySQL中，更新、新增、删除写操作，会加悲观锁，具有原子性，可以解决并发问题。</p>
<p>在 <code>StockService</code> 中调用该Mapper方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void deduct() &#123;</span><br><span class="line">    this.stockMapper.updateStock(&quot;1001&quot;, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>

<p>在集群部署情况下，使用JMeter进行压力测试，5000个请求成功发出，最终库存为0。</p>
<h4 id="1-3-2-优缺点"><a href="#1-3-2-优缺点" class="headerlink" title="1.3.2 优缺点"></a>1.3.2 优缺点</h4><p>优点：</p>
<ol>
<li>可以解决多例模式、事务、集群部署下的并发问题</li>
</ol>
<p>缺点：</p>
<ol>
<li>锁范围问题</li>
<li>同一个商品有多条库存记录（多仓库）<ul>
<li>如果仍然使用该方法，则会对所有仓库库存数进行自减</li>
<li>正常情况应灵活从各个仓库进行减库存发货</li>
</ul>
</li>
<li>无法记录库存变化前后的状态<ul>
<li>原因：单条SQL语句</li>
</ul>
</li>
</ol>
<h5 id="锁范围问题"><a href="#锁范围问题" class="headerlink" title="锁范围问题"></a>锁范围问题</h5><p>表级锁 VS 行级锁</p>
<ul>
<li><p>未添加索引之前为 <code>表级锁</code></p>
<ul>
<li>在用户a中，先开启事务，再去更新 <code>productCode = 1001</code> 记录，但不提交事务</li>
<li>这导致：在用户b中，更新 <code>productCode = 1002</code> 记录，但进入了阻塞</li>
<li>用户a提交了事务之后，用户b才能提交成功，证明为表级锁</li>
</ul>
</li>
<li><p>添加索引之后为 <code>行级锁</code></p>
<ol>
<li><p>锁的查询或更新条件必须为索引字段</p>
<p>e.g.：根据 <code>productCode</code> 进行查询或更新，为其添加索引</p>
<p><a target="_blank" rel="noopener" href="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/iShot2022-10-08%2023.44.31.png"><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/iShot2022-10-08%2023.44.31.png" alt="img"></a></p>
</li>
<li><p>再次进行之前的操作，用户b不会进入阻塞，即变为了行级锁</p>
</li>
<li><p>使用行级锁的条件：</p>
<p>. 查询或者更新条件必须为索引字段</p>
<p>. 查询或者更新条件必须为具体值</p>
<p>. SQL语句中where条件有索引时，不能为 <code>&#39;like&#39;</code> 或者 <code>&#39;!=&#39;</code>，否则为表级锁</p>
</li>
</ol>
</li>
</ul>
<h3 id="1-4-悲观锁"><a href="#1-4-悲观锁" class="headerlink" title="1.4 悲观锁"></a>1.4 悲观锁</h3><p>select … for update</p>
<h4 id="1-4-1-情景引入"><a href="#1-4-1-情景引入" class="headerlink" title="1.4.1 情景引入"></a>1.4.1 情景引入</h4><p>用户a与b并发执行</p>
<ol>
<li><p>用户a开启事务，并使用如下SQL语句查询库存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from db_stock where product_code=&#x27;1001&#x27;;</span><br><span class="line"></span><br><span class="line">SQL</span><br></pre></td></tr></table></figure>
</li>
<li><p>用户b使用如下SQL语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update db_stock set count = count - 1 where id=1;</span><br><span class="line"></span><br><span class="line">SQL</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这时库存已经发生变化，而用户a不知情，仍会已它查出来的库存数作为标准进行下一步操作</p>
<p>解决方案：用户a采用如下SQL语句，进行加锁操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from db_stock where product_code=&#x27;1001&#x27; for update;</span><br><span class="line"></span><br><span class="line">SQL</span><br></pre></td></tr></table></figure>

<p>加锁范围：此时满足行级锁条件，因此该悲观锁为行级锁，只锁对应的记录</p>
<h4 id="1-4-2-代码实现"><a href="#1-4-2-代码实现" class="headerlink" title="1.4.2 代码实现"></a>1.4.2 代码实现</h4><ol>
<li><p>在StockMapper中添加查询库存方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Select(&quot;select * from db_stock where product_code=#&#123;productCode&#125; for update&quot;)</span><br><span class="line">List&lt;Stock&gt; queryStock(String productCode);</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新StockService方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">public void deduct() &#123;</span><br><span class="line">    // 查询库存信息并锁定</span><br><span class="line">    List&lt;Stock&gt; stocks = this.stockMapper.queryStock(&quot;1001&quot;);</span><br><span class="line">    // 取第一个库存</span><br><span class="line">    Stock stock = stocks.get(0);</span><br><span class="line">    // 判断库存是否充足</span><br><span class="line">    if (stock != null &amp;&amp; stock.getCount() &gt; 0) &#123;</span><br><span class="line">        // 扣减库存</span><br><span class="line">        stock.setCount(stock.getCount() - 1);</span><br><span class="line">        this.stockMapper.updateById(stock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用压力测试工具进行测试，库存数量减为0，解决了并发问题</p>
</li>
</ol>
<h4 id="1-4-3-优缺点"><a href="#1-4-3-优缺点" class="headerlink" title="1.4.3 优缺点"></a>1.4.3 优缺点</h4><p>优点：更加灵活</p>
<ol>
<li><p>解决同一个商品有多条库存记录的问题</p>
<p>可以先根据商品编号查询库存记录，查询到之后再根据现有技术分析。</p>
</li>
<li><p>解决无法记录库存变化前后状态的问题</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>性能问题：效率比JVM本地锁稍高一些，但比单SQL语句低</p>
</li>
<li><p>死锁问题：对多条数据加锁时，加锁顺序必须一致</p>
<p>e.g.：用户a与b执行如下顺序操作</p>
<ol>
<li>用户a对 <code>id=1</code> 商品加锁</li>
<li>用户b对 <code>id=2</code> 商品加锁</li>
<li>用户a想对 <code>id=2</code> 商品加锁，但陷入阻塞</li>
<li>用户b想对 <code>id=1</code> 商品加锁，报错 Deadlock</li>
</ol>
</li>
<li><p>库存操作需要统一</p>
</li>
</ol>
<h3 id="1-5-乐观锁"><a href="#1-5-乐观锁" class="headerlink" title="1.5 乐观锁"></a>1.5 乐观锁</h3><p>借助时间戳、version版本号实现，利用 <code>CAS</code> 机制</p>
<p>CAS：Compare and Swap 比较并交换</p>
<p>关于CAS，可以看看这篇博客：<a class="link" target="_blank" rel="noopener" href="https://www.cnblogs.com/myopensource/p/8177074.html">漫画：什么是CAS机制<i class="fas fa-external-link-alt"></i></a></p>
<ul>
<li>如果变量 <code>X</code> 等于旧值 <code>A</code>，则更新将 <code>X</code> 更新为 <code>B</code></li>
<li>若不等于，则放弃更新</li>
</ul>
<h4 id="1-5-1-实现思路"><a href="#1-5-1-实现思路" class="headerlink" title="1.5.1 实现思路"></a>1.5.1 实现思路</h4><ol>
<li><p>在 <code>db_stock</code> 表中添加 <code>version</code> 字段</p>
<p>类型为int，长度11，Not Null</p>
</li>
<li><p>查询对应的商品库存以及 <code>version</code> 号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM db_stock where product_code=&#x27;1001&#x27;;</span><br><span class="line"></span><br><span class="line">SQL</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行更新库存操作时，where条件中需要确认当前 <code>version</code> 是否等于之前查出来的</p>
<p>. 若等于，则更新库存操作成功</p>
<p>. 否则，则说明存在并发操作，该条库存数据已被修改。继续查询重试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE db_stock SET count=4999, version=version+1 WHERE id=1 AND version=0;</span><br><span class="line"></span><br><span class="line">SQL</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="1-5-2-代码实现"><a href="#1-5-2-代码实现" class="headerlink" title="1.5.2 代码实现"></a>1.5.2 代码实现</h4><p>在 Stock 实体类中添加 <code>version</code> 属性，类型为Integer</p>
<p>修改 StcokService 中的deduct()方法</p>
<h5 id="第一版代码"><a href="#第一版代码" class="headerlink" title="第一版代码"></a>第一版代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">public void deduct() &#123;</span><br><span class="line">    // 查询库存信息并锁定</span><br><span class="line">    List&lt;Stock&gt; stocks = this.stockMapper.selectList(new QueryWrapper&lt;Stock&gt;().eq(&quot;product_code&quot;, &quot;1001&quot;));</span><br><span class="line">    // 取第一个库存</span><br><span class="line">    Stock stock = stocks.get(0);</span><br><span class="line">    // 判断库存是否充足</span><br><span class="line">    if (stock != null &amp;&amp; stock.getCount() &gt; 0) &#123;</span><br><span class="line">        // 扣减库存</span><br><span class="line">        stock.setCount(stock.getCount() - 1);</span><br><span class="line">        Integer version = stock.getVersion();</span><br><span class="line">        stock.setVersion(version + 1);</span><br><span class="line">        int update = this.stockMapper.update(stock, new UpdateWrapper&lt;Stock&gt;().eq(&quot;id&quot;, stock.getId()).eq(&quot;version&quot;, version));</span><br><span class="line">        if (update == 0) &#123;</span><br><span class="line">            deduct();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>

<p>采用JMeter压力测试工具测试时，报错</p>
<p>错误分析：</p>
<ol>
<li><p>stack over flow：栈溢出</p>
<p><a target="_blank" rel="noopener" href="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/stackoverflow.png"><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/stackoverflow.png" alt="img"></a></p>
<p>这是由于高并发的情况下，更新失败率很高，就会不断地递归调用deduct方法，导致栈溢出。</p>
<p>解决方案：调用线程类中的sleep方法，暂时睡眠，避开并发高峰</p>
</li>
<li><p>连接超时错误</p>
<p><a target="_blank" rel="noopener" href="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/timeout.png"><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/timeout.png" alt="img"></a></p>
<p>这是由于开启了事务注解，为手动事务。</p>
<p>当执行到更新操作时，会对数据进行加锁。而当前请求无法更新，就会一直调用deduct方法，并一直持有锁。其他请求进入代码，会进入阻塞状态，直至连接超时。</p>
<p>而关闭了事务注解，为自动事务。若更新操作执行失败，会放弃锁。</p>
</li>
</ol>
<h5 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void deduct() &#123;</span><br><span class="line">    // 查询库存信息并锁定</span><br><span class="line">    List&lt;Stock&gt; stocks = this.stockMapper.selectList(new QueryWrapper&lt;Stock&gt;().eq(&quot;product_code&quot;, &quot;1001&quot;));</span><br><span class="line">    // 取第一个库存</span><br><span class="line">    Stock stock = stocks.get(0);</span><br><span class="line">    // 判断库存是否充足</span><br><span class="line">    if (stock != null &amp;&amp; stock.getCount() &gt; 0) &#123;</span><br><span class="line">        // 扣减库存</span><br><span class="line">        stock.setCount(stock.getCount() - 1);</span><br><span class="line">        Integer version = stock.getVersion();</span><br><span class="line">        stock.setVersion(version + 1);</span><br><span class="line">        int update = this.stockMapper.update(stock, new UpdateWrapper&lt;Stock&gt;().eq(&quot;id&quot;, stock.getId()).eq(&quot;version&quot;, version));</span><br><span class="line">        if (update == 0) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(20);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            deduct();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>

<p>通过JMeter测试，最终库存减为0</p>
<h4 id="1-5-3-优缺点"><a href="#1-5-3-优缺点" class="headerlink" title="1.5.3 优缺点"></a>1.5.3 优缺点</h4><p>推荐阅读：<a class="link" target="_blank" rel="noopener" href="https://www.cnblogs.com/qjjazry/p/6581568.html">Java并发问题–乐观锁与悲观锁以及乐观锁的一种实现方式-CAS<i class="fas fa-external-link-alt"></i></a></p>
<p>优点：</p>
<ol>
<li>乐观锁在竞争不激烈时，较悲观锁更具有优势，因为悲观锁会锁住代码块，并且加锁、释放锁、线程上下文均占用额外资源。</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>在高并发情况下，乐观锁的性能不如悲观锁，因为重试次数过多。</p>
</li>
<li><p>乐观锁存在ABA问题</p>
<p>. 在查询与更新的中间，<code>X</code> 值被多次更改，但最终又回到了查询时的值</p>
</li>
<li><p>读写分离情况下，乐观锁不可靠</p>
<p>从数据库与主数据库进行网络传输，具有较大时延，可能主数据库内是新数据，而从数据库内是旧数据，乐观锁下会造成从数据库不断地重试，</p>
</li>
</ol>
<h3 id="1-6-MySQL锁总结"><a href="#1-6-MySQL锁总结" class="headerlink" title="1.6 MySQL锁总结"></a>1.6 MySQL锁总结</h3><p>性能：单SQL语句 &gt; 悲观锁 &gt; JVM锁 &gt; 乐观锁</p>
<ul>
<li>追求极致性能、业务场景简单、无需记录数据更新前后变化的情况下 -&gt; 单SQL语句</li>
<li>并发量低、读多于写、竞争不激烈的情况下 -&gt; 乐观锁</li>
<li>并发量高、冲突激烈 -&gt; 悲观锁</li>
<li>不推荐JVM锁</li>
</ul>
<h3 id="1-7-Redis锁"><a href="#1-7-Redis锁" class="headerlink" title="1.7 Redis锁"></a>1.7 Redis锁</h3><h4 id="1-7-1-并发问题引入"><a href="#1-7-1-并发问题引入" class="headerlink" title="1.7.1 并发问题引入"></a>1.7.1 并发问题引入</h4><ol>
<li><p>在Maven工程pom.xml文件中加入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">XML</span><br></pre></td></tr></table></figure>
</li>
<li><p>在application.properties文件中配置redis</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.redis.host=localhost</span><br><span class="line">spring.redis.password=123456</span><br><span class="line"></span><br><span class="line">PROPERTIES</span><br></pre></td></tr></table></figure>
</li>
<li><p>更改 StockService类中的deduct方法</p>
<p>采用StringRedisTemplate更加方便</p>
<p>而RedisTemplate需要手动设置序列化器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">public void deduct() &#123;</span><br><span class="line">    // 查询库存信息</span><br><span class="line">    String stock = this.redisTemplate.opsForValue().get(&quot;stock&quot;);</span><br><span class="line">    // 判断库存是否充足</span><br><span class="line">    if (stock != null &amp;&amp; stock.length() != 0) &#123;</span><br><span class="line">        Integer st = Integer.valueOf(stock);</span><br><span class="line">        if (st &gt; 0) &#123;</span><br><span class="line">            // 扣减库存</span><br><span class="line">            this.redisTemplate.opsForValue().set(&quot;stock&quot;, String.valueOf(--st));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>
</li>
<li><p>在redis-cli命令窗口中，设置库存：<code>set stock 5000</code></p>
</li>
</ol>
<p>启动SpringBoot与压力测试工具JMeter，最终库存不为0，出现并发问题。</p>
<h4 id="1-7-2-解决方案"><a href="#1-7-2-解决方案" class="headerlink" title="1.7.2 解决方案"></a>1.7.2 解决方案</h4><ol>
<li>JVM本地锁机制（较简单不做演示）</li>
<li>Redis乐观锁：<code>watch</code> <code>multi</code> <code>exec</code><ol>
<li>watch：监控一个或多个key的值，如果exec执行之前，如果key的值发生变化，则取消事务执行。</li>
<li>multi：开启事务</li>
<li>exec：执行事务</li>
</ol>
</li>
</ol>
<h4 id="1-7-3-代码实现"><a href="#1-7-3-代码实现" class="headerlink" title="1.7.3 代码实现"></a>1.7.3 代码实现</h4><p>修改StockService中的deduct方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public void deduct() &#123;</span><br><span class="line">    this.redisTemplate.execute(new SessionCallback&lt;Object&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Object execute(RedisOperations operations) throws DataAccessException &#123;</span><br><span class="line">            operations.watch(&quot;stock&quot;);</span><br><span class="line">            // 查询库存信息</span><br><span class="line">            String stock = operations.opsForValue().get(&quot;stock&quot;).toString();</span><br><span class="line">            // 判断库存是否充足</span><br><span class="line">            if (stock != null &amp;&amp; stock.length() != 0) &#123;</span><br><span class="line">                Integer st = Integer.valueOf(stock);</span><br><span class="line">                if (st &gt; 0) &#123;</span><br><span class="line">                    // multi</span><br><span class="line">                    operations.multi();</span><br><span class="line">                    // 扣减库存</span><br><span class="line">                    operations.opsForValue().set(&quot;stock&quot;, String.valueOf(--st));</span><br><span class="line">                    // exec 执行事务</span><br><span class="line">                    List exec = operations.exec();</span><br><span class="line">                    // 如果事务执行结果为空，代表操作失败，重试</span><br><span class="line">                    if (exec == null || exec.size() == 0) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            Thread.sleep(40);</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            throw new RuntimeException(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                        deduct();</span><br><span class="line">                    &#125;</span><br><span class="line">                    return exec;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>

<p>采用JMeter进行并发测试后，库存减为0，解决了并发问题</p>
<p>但是吞吐量性能较低，甚至可能由于电脑性能问题，出现连接不够用的情况。</p>
<h2 id="2-Redis分布式锁"><a href="#2-Redis分布式锁" class="headerlink" title="2. Redis分布式锁"></a>2. Redis分布式锁</h2><h3 id="2-1-实现思路"><a href="#2-1-实现思路" class="headerlink" title="2.1 实现思路"></a>2.1 实现思路</h3><p>借助于redis中的命令 <code>setnx(key, value)</code></p>
<p>设置 <code>key</code> 为lock</p>
<ul>
<li>若 <code>lock</code> 存在，则说明有其他请求已经获取到锁，则当前请求重复重试</li>
<li>若 <code>lock</code> 不存在，则说明当前锁未被获取，当前请求获取锁成功，继续执行业务操作</li>
<li>设置 <code>lock</code> 之后，只有一个请求可以获取到锁并执行成功，其他请求只能等待</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/1606626611922.png"><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/1606626611922.png" alt="img"></a></p>
<h3 id="2-2-基本代码实现"><a href="#2-2-基本代码实现" class="headerlink" title="2.2 基本代码实现"></a>2.2 基本代码实现</h3><h4 id="2-2-1-递归版本"><a href="#2-2-1-递归版本" class="headerlink" title="2.2.1 递归版本"></a>2.2.1 递归版本</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public void deduct() &#123;</span><br><span class="line">    // 加锁setnx</span><br><span class="line">    Boolean lock = this.redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, &quot;123&quot;);</span><br><span class="line">    // 递归调用</span><br><span class="line">    if (!lock) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(50);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        deduct();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 查询库存信息</span><br><span class="line">            String stock = redisTemplate.opsForValue().get(&quot;stock&quot;).toString();</span><br><span class="line">            // 判断库存是否充足</span><br><span class="line">            if (stock != null &amp;&amp; stock.length() != 0) &#123;</span><br><span class="line">                Integer st = Integer.valueOf(stock);</span><br><span class="line">                if (st &gt; 0) &#123;</span><br><span class="line">                    // 扣减库存</span><br><span class="line">                    redisTemplate.opsForValue().set(&quot;stock&quot;, String.valueOf(--st));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 解锁</span><br><span class="line">            this.redisTemplate.delete(&quot;lock&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-循环版本"><a href="#2-2-2-循环版本" class="headerlink" title="2.2.2 循环版本"></a>2.2.2 循环版本</h4><p>注意：即使不采用递归版本，在重试获取锁的过程中，也可以使用线程睡眠，这样可以减小锁的竞争压力，提升性能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public void deduct() &#123;</span><br><span class="line">    // 加锁setnx</span><br><span class="line">    while (!this.redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, &quot;123&quot;)) &#123;</span><br><span class="line">        // 循环重试</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(50);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 查询库存信息</span><br><span class="line">        String stock = redisTemplate.opsForValue().get(&quot;stock&quot;).toString();</span><br><span class="line">        // 判断库存是否充足</span><br><span class="line">        if (stock != null &amp;&amp; stock.length() != 0) &#123;</span><br><span class="line">            Integer st = Integer.valueOf(stock);</span><br><span class="line">            if (st &gt; 0) &#123;</span><br><span class="line">                // 扣减库存</span><br><span class="line">                redisTemplate.opsForValue().set(&quot;stock&quot;, String.valueOf(--st));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 解锁</span><br><span class="line">        this.redisTemplate.delete(&quot;lock&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>

<h3 id="2-3-问题解决"><a href="#2-3-问题解决" class="headerlink" title="2.3 问题解决"></a>2.3 问题解决</h3><h4 id="2-3-1-死锁与原子性"><a href="#2-3-1-死锁与原子性" class="headerlink" title="2.3.1 死锁与原子性"></a>2.3.1 死锁与原子性</h4><p>在某一请求获取到lock锁之后，当前服务器突然宕机，造成该锁无法得到释放，此时其他请求仍然处于不断地递归或循环重试获取锁，造成死循环。</p>
<p>解决方案：获取到lock之后，为lock设置过期时间，<code>expire</code> 指令</p>
<p>但是：可能在 获取lock 与 为lock设置过期时间 之间，服务器发生宕机。</p>
<p>因此，需要确保两个操作的原子性：采用如下指令，将多个操作复合到一个指令中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set lock 123 ex 20 nx</span><br><span class="line"></span><br><span class="line">APACHE</span><br></pre></td></tr></table></figure>

<p>修改加锁部分的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">while (!this.redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, &quot;123&quot;, 3, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    // 循环重试</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(50);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-防误删"><a href="#2-3-2-防误删" class="headerlink" title="2.3.2 防误删"></a>2.3.2 防误删</h4><p>假设处理请求的时长大于锁的有效时间，当某一请求还未执行完当前操作时，Redis锁便会自动释放掉（删除lock），等到该请求执行完当前操作后，还会手动地将Redis锁释放掉。此时，可能别的请求已经获取到了锁，那么该锁很有可能被该请求误删掉。</p>
<p><strong>解决方案：</strong></p>
<p>为了防止出现这一情况，需要为当前锁设置唯一标识UUID，作为锁的值。</p>
<p>在删除锁之前，先判断当前锁是否属于自己，然后再进行删除。</p>
<p>修改 StockService 的 deduct方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public void deduct() &#123;</span><br><span class="line">    String uuid = UUID.randomUUID().toString();</span><br><span class="line">    // 加锁setnx</span><br><span class="line">    while (!this.redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, uuid, 3, TimeUnit.SECONDS)) &#123;</span><br><span class="line">        // 循环重试</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(50);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 查询库存信息</span><br><span class="line">        String stock = redisTemplate.opsForValue().get(&quot;stock&quot;).toString();</span><br><span class="line">        // 判断库存是否充足</span><br><span class="line">        if (stock != null &amp;&amp; stock.length() != 0) &#123;</span><br><span class="line">            Integer st = Integer.valueOf(stock);</span><br><span class="line">            if (st &gt; 0) &#123;</span><br><span class="line">                // 扣减库存</span><br><span class="line">                redisTemplate.opsForValue().set(&quot;stock&quot;, String.valueOf(--st));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 先判断，再解锁</span><br><span class="line">        if (StringUtils.equals(this.redisTemplate.opsForValue().get(&quot;lock&quot;), uuid)) &#123;</span><br><span class="line">            this.redisTemplate.delete(&quot;lock&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>

<p>判断与删除操作需要保证原子性，否则还会出现并发问题</p>
<ul>
<li>刚判断完该锁是自己的，还没进行删除，锁就到期自动释放且被其他请求获取，此时会造成误删操作</li>
</ul>
<p>借助 <code>lua</code> 脚本实现原子性操作：<a class="link" target="_blank" rel="noopener" href="https://www.runoob.com/lua/lua-tutorial.html">Lua 教程 | 菜鸟教程<i class="fas fa-external-link-alt"></i></a></p>
<p>redis-cli支持lua脚本，可以一次性给redis发送多个指令。</p>
<ul>
<li>redis为单线程，执行指令遵守 <code>one-by-one</code> 规则</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EVAL script numkeys [key [key ...]] [arg [arg ...]]</span><br><span class="line"></span><br><span class="line">INFORM7</span><br></pre></td></tr></table></figure>

<p>删除LUA脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end</span><br><span class="line"></span><br><span class="line">LUA</span><br></pre></td></tr></table></figure>

<p>更改代码中finally部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 先判断，再解锁</span><br><span class="line">String script = &quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] &quot; +</span><br><span class="line">        &quot;then return redis.call(&#x27;del&#x27;, KEYS[1]) &quot; +</span><br><span class="line">        &quot;else return 0 &quot; +</span><br><span class="line">        &quot;end&quot;;</span><br><span class="line">this.redisTemplate.execute(new DefaultRedisScript&lt;&gt;(script, Boolean.class), Arrays.asList(&quot;lock&quot;), uuid);</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>

<h4 id="2-3-3-可重入性"><a href="#2-3-3-可重入性" class="headerlink" title="2.3.3 可重入性"></a>2.3.3 可重入性</h4><p>之前的加锁指令采用的是Redis中的 <code>setnx</code> 指令，即锁的名字固定为lock（键值固定），一旦加锁成功（键设置成功），该线程便无法继续加锁。如下即为具体情景代码：</p>
<p>某线程执行a方法，获取到锁之后，其又需要继续执行b方法，需要继续获取锁。但此时锁已经被自己占有，相当于自己和自己产生了死锁，这是不可重入锁带来的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void a() &#123;</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public synchronized void b() &#123;</span><br><span class="line">    // pass</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>

<p><strong>解决方案：可重入锁</strong></p>
<p>可重入锁可：当某一线程获得锁之后，需要再次执行加锁方法时（锁对象为同一个），将加锁次数加1即可。执行完毕之后，释放锁时对加锁次数减1。当加锁次数等于0时，说明该锁已经被完全释放。</p>
<p>当可重入锁需要在分布式环境实现时，需要统计加锁次数。</p>
<p><strong>实现方案：Redis Hash + lua脚本</strong></p>
<p>加锁 -&gt; 判断锁是否存在：<code>exists</code></p>
<ul>
<li>若不存在，则直接创建锁并获取：<code>hset key field value</code></li>
<li>若存在，则判断当前锁是否属于自己：<code>hexists</code><ul>
<li>若属于，则重入：<code>hincrby key field increment</code></li>
<li>若不属于，递归或循环自旋重试</li>
</ul>
</li>
</ul>
<p><strong>加锁脚本</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if redis.call(&#x27;exists&#x27;, KEYS[1]) == 0 or redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1 </span><br><span class="line">then</span><br><span class="line">    redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], 1)</span><br><span class="line">    redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2])</span><br><span class="line">    return 1</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">LUA</span><br></pre></td></tr></table></figure>

<p>解锁 -&gt; 判断锁是否属于自己：<code>hexists</code></p>
<ul>
<li>若不属于，说明正在恶意释放锁，返回 <code>nil</code></li>
<li>若属于，对加锁次数减1，并判断当前加锁次数是否为0<ul>
<li>若为0，则返回1，代表完全解锁成功</li>
<li>若不为0，则返回0</li>
</ul>
</li>
</ul>
<p><strong>解锁脚本</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 0</span><br><span class="line">then </span><br><span class="line">    return nil</span><br><span class="line">elseif redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], -1) == 0</span><br><span class="line">then </span><br><span class="line">    return redis.call(&#x27;del&#x27;, KEYS[1])</span><br><span class="line">else </span><br><span class="line">    return 0</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">LUA</span><br></pre></td></tr></table></figure>

<p><strong>代码实现</strong></p>
<ol>
<li><p>创建分布式锁的工厂类方法。通过一个工厂类方法，可以获得不同的分布式锁（基于Redis、基于Zookeeper、基于MySQL）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class DistributedLockClient &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    private String uuid;</span><br><span class="line"></span><br><span class="line">    public DistributedLockClient() &#123;</span><br><span class="line">        this.uuid = UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DistributedRedisLock getRedisLock(String lockName) &#123;</span><br><span class="line">        return new DistributedRedisLock(redisTemplate, lockName, uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建分布式Redis锁的实现类，其实现了Lock接口。通过之前编写好的加锁、解锁脚本，实现了可重入锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">public class DistributedRedisLock implements Lock &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    public String lockName;</span><br><span class="line"></span><br><span class="line">    private String uuid;</span><br><span class="line"></span><br><span class="line">    private long expire = 30;</span><br><span class="line"></span><br><span class="line">    public DistributedRedisLock(StringRedisTemplate redisTemplate, String lockName, String uuid) &#123;</span><br><span class="line">        this.redisTemplate = redisTemplate;</span><br><span class="line">        this.lockName = lockName;</span><br><span class="line">        this.uuid = uuid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        this.tryLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return this.tryLock(-1L, TimeUnit.SECONDS);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">        this.expire = time != -1 ? unit.toSeconds(time) : expire;</span><br><span class="line">        String script = &quot;if redis.call(&#x27;exists&#x27;, KEYS[1]) == 0 or redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1 \n&quot; +</span><br><span class="line">                        &quot;then\n&quot; +</span><br><span class="line">                        &quot;    redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], 1)\n&quot; +</span><br><span class="line">                        &quot;    redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2])\n&quot; +</span><br><span class="line">                        &quot;    return 1\n&quot; +</span><br><span class="line">                        &quot;else\n&quot; +</span><br><span class="line">                        &quot;    return 0\n&quot; +</span><br><span class="line">                        &quot;end&quot;;</span><br><span class="line">        while (!this.redisTemplate.execute(new DefaultRedisScript&lt;&gt;(script, Boolean.class), Arrays.asList(lockName), getId(), String.valueOf(expire))) &#123;</span><br><span class="line">            Thread.sleep(50);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        String script = &quot;if redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 0\n&quot; +</span><br><span class="line">                        &quot;then \n&quot; +</span><br><span class="line">                        &quot;    return nil\n&quot; +</span><br><span class="line">                        &quot;elseif redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], -1) == 0\n&quot; +</span><br><span class="line">                        &quot;then \n&quot; +</span><br><span class="line">                        &quot;    return redis.call(&#x27;del&#x27;, KEYS[1])\n&quot; +</span><br><span class="line">                        &quot;else \n&quot; +</span><br><span class="line">                        &quot;    return 0\n&quot; +</span><br><span class="line">                        &quot;end&quot;;</span><br><span class="line">        Long flag = this.redisTemplate.execute(new DefaultRedisScript&lt;&gt;(script, Long.class), Arrays.asList(lockName), getId());</span><br><span class="line">        if (flag == null) &#123;</span><br><span class="line">            throw new IllegalMonitorStateException(&quot;this lock does not belong to you&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Condition newCondition() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String getId() &#123;</span><br><span class="line">        return uuid + &quot;:&quot; + Thread.currentThread().getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改StockService中的deduct方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void deduct() &#123;</span><br><span class="line">    DistributedRedisLock redisLock = this.distributedLockClient.getRedisLock(&quot;lock&quot;);</span><br><span class="line">    redisLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 查询库存信息</span><br><span class="line">        String stock = redisTemplate.opsForValue().get(&quot;stock&quot;).toString();</span><br><span class="line">        // 判断库存是否充足</span><br><span class="line">        if (stock != null &amp;&amp; stock.length() != 0) &#123;</span><br><span class="line">            Integer st = Integer.valueOf(stock);</span><br><span class="line">            if (st &gt; 0) &#123;</span><br><span class="line">                // 扣减库存</span><br><span class="line">                redisTemplate.opsForValue().set(&quot;stock&quot;, String.valueOf(--st));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        this.test();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        redisLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure></li>
</ol>
<p>需要注意的一点是：如何去标识每一个服务中的每一个线程的锁的uuid？</p>
<p>这里的解决方案是：通过服务生成的uuid与每个线程的线程id拼接得到唯一标识uuid</p>
<ol>
<li><p>每一个服务是通过DistributedLockClient这一工厂类获得锁，由于该类交给Spring容器管理，是单例对象。即每一个服务只有一个唯一的DistributedLockClient对象。</p>
<p>因此可以在该类构造方法上生成一个uuid，作为当前服务的唯一标识</p>
</li>
<li><p>每一个线程也会有一个唯一的id</p>
</li>
<li><p>将两者拼接起来（getId方法），即可唯一标识每一个服务的每一个线程。若需要进行重入操作，同一线程重复获取锁，可通过此唯一标识进行判断。</p>
</li>
</ol>
<p>反之，如果每次通过DistributedLockClient获取Redis分布式锁，均重新创建一个新的uuid，那么便永远无法实现可重入锁。</p>
<ul>
<li>因为在同一线程进行可重入操作获取锁时，会出现内层锁与外层锁uuid不匹配的错误情况，与理论事实相矛盾。</li>
</ul>
<h4 id="2-3-4-自动续期"><a href="#2-3-4-自动续期" class="headerlink" title="2.3.4 自动续期"></a>2.3.4 自动续期</h4><p>假设处理请求的时长大于锁的有效时间，会出现请求还未处理完，锁就被释放了，此时可能引起并发问题。</p>
<p><strong>解决方案：</strong></p>
<ul>
<li><p>采用Timer定时任务，每隔一段时间为锁续期</p>
</li>
<li><p>配合lua脚本执行最后的续期操作</p>
<p>先判断锁是否存在。若存在则重置过期时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if(redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1) </span><br><span class="line">then </span><br><span class="line">    redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2])</span><br><span class="line">    return 1</span><br><span class="line">else </span><br><span class="line">    return 0</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">LUA</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void renewExpire() &#123;</span><br><span class="line">    String script = &quot;if(redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1) \n&quot; +</span><br><span class="line">                    &quot;then \n&quot; +</span><br><span class="line">                    &quot;    redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2])\n&quot; +</span><br><span class="line">                    &quot;    return 1\n&quot; +</span><br><span class="line">                    &quot;else \n&quot; +</span><br><span class="line">                    &quot;    return 0\n&quot; +</span><br><span class="line">                    &quot;end&quot;;</span><br><span class="line">    new Timer().schedule(new TimerTask() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            if (redisTemplate.execute(new DefaultRedisScript&lt;&gt;(script, Boolean.class), Arrays.asList(lockName), uuid, String.valueOf(expire))) &#123;</span><br><span class="line">                renewExpire();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, this.expire * 1000 / 3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>

<p>其中需要注意的点是：</p>
<ul>
<li><p>之前是通过 <code>getId()</code> 方法，将当前服务的uuid与当前线程的id拼接到一起，组成唯一标识。</p>
<p>而现在的问题为：Timer定时任务是子线程，它的本意是监测主线程的锁的过期时间并为其续期，但是在其内部调用getId方法，得到的锁唯一标识是拼接的Timer定时任务子线程的id。</p>
</li>
<li><p>因此，需要对代码进行进一步修改与优化，删去getId方法，修改DistributedRedisLock的构造方法，在创建该类时便生成唯一的uuid。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public DistributedRedisLock(StringRedisTemplate redisTemplate, String lockName, String uuid) &#123;</span><br><span class="line">    this.redisTemplate = redisTemplate;</span><br><span class="line">    this.lockName = lockName;</span><br><span class="line">    this.uuid = uuid + &quot;:&quot; + Thread.currentThread().getId();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-4-RedLock红锁算法"><a href="#2-4-RedLock红锁算法" class="headerlink" title="2.4 RedLock红锁算法"></a>2.4 RedLock红锁算法</h3><p>我结合老师的讲解，单独写了一篇<a class="link" target="_blank" rel="noopener" href="https://ltyzzzxxx.github.io/2022/10/09/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">图文详解RedLock（结合官方文档）<i class="fas fa-external-link-alt"></i></a></p>
<p>其中一些内容参照了官方文档以及其他大佬的博客</p>
<p>这一部分均为理论内容，没有实际代码</p>
<h3 id="2-5-Redisson"><a href="#2-5-Redisson" class="headerlink" title="2.5 Redisson"></a>2.5 Redisson</h3><h4 id="2-5-1-环境搭建"><a href="#2-5-1-环境搭建" class="headerlink" title="2.5.1 环境搭建"></a>2.5.1 环境搭建</h4><p>参考 <a class="link" target="_blank" rel="noopener" href="https://github.com/redisson/redisson/wiki">Redisson文档<i class="fas fa-external-link-alt"></i></a></p>
<ol>
<li><p>引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;  </span><br><span class="line">    &lt;groupId&gt;org.redisson&lt;/groupId&gt;  </span><br><span class="line">    &lt;artifactId&gt;redisson&lt;/artifactId&gt;  </span><br><span class="line">    &lt;version&gt;3.17.1&lt;/version&gt;  </span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">XML</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于Redisson不能使用yml进行配置，因此需要编写额外的配置类</p>
<p>新建 <code>config</code> 包，创建 <code>RedissonConfig</code> 类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RedissonConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public RedissonClient redissonClient() &#123;</span><br><span class="line">        Config config = new Config();</span><br><span class="line">        config.useSingleServer().setAddress(&quot;redis://127.0.0.1:6379&quot;).setPassword(&quot;123456&quot;).setDatabase(0);</span><br><span class="line">        return Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 <code>StockService</code> 中的 <code>deduct</code> 方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Autowired  </span><br><span class="line">private RedissonClient redissonClient;  </span><br><span class="line"></span><br><span class="line">public void deduct() &#123;  </span><br><span class="line">    RLock lock = this.redissonClient.getLock(&quot;lock&quot;);  </span><br><span class="line">    lock.lock();  </span><br><span class="line">    // 查询库存信息  </span><br><span class="line">    String stock = redisTemplate.opsForValue().get(&quot;stock&quot;).toString();  </span><br><span class="line">    // 判断库存是否充足  </span><br><span class="line">    try &#123;  </span><br><span class="line">        if (stock != null &amp;&amp; stock.length() != 0) &#123;  </span><br><span class="line">            Integer st = Integer.valueOf(stock);  </span><br><span class="line">            if (st &gt; 0) &#123;  </span><br><span class="line">                // 扣减库存  </span><br><span class="line">                redisTemplate.opsForValue().set(&quot;stock&quot;, String.valueOf(--st));  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; finally &#123;  </span><br><span class="line">        lock.unlock();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>

<p>也可以设置lock的过期时间，到时间时自动释放锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lock.lock(10, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure></li>
</ol>
<p>常用的Redisson配置</p>
<p><a target="_blank" rel="noopener" href="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/iShot2022-10-12%2017.07.13.png"><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/iShot2022-10-12%2017.07.13.png" alt="img"></a></p>
<h4 id="2-5-2-可重入锁"><a href="#2-5-2-可重入锁" class="headerlink" title="2.5.2 可重入锁"></a>2.5.2 可重入锁</h4><h5 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h5><p>RLock接口的lock方法是通过继承JUC包下的Lock接口获得，最终RedissonLock间接实现了RLock接口以及其中的中法。</p>
<p>继承关系如图所示：</p>
<p><a target="_blank" rel="noopener" href="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/rlock.png"><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/rlock.png" alt="img"></a></p>
<p>RedissonLock中具体lock方法实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override  </span><br><span class="line">public void lock() &#123;  </span><br><span class="line">    try &#123;  </span><br><span class="line">        lock(-1, null, false);  </span><br><span class="line">    &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">        throw new IllegalStateException();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>

<p>根据顺序，一步步进入方法查看：</p>
<p>lock -&gt; tryAcquire -&gt; tryAcquireAsync -&gt; tryLockInnerAsync</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; RFuture&lt;T&gt; tryLockInnerAsync(long waitTime, long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand&lt;T&gt; command) &#123;  </span><br><span class="line">    return evalWriteAsync(getRawName(), LongCodec.INSTANCE, command,  </span><br><span class="line">            &quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot; +  </span><br><span class="line">                    &quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot; +  </span><br><span class="line">                    &quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot; +  </span><br><span class="line">                    &quot;return nil; &quot; +  </span><br><span class="line">                    &quot;end; &quot; +  </span><br><span class="line">                    &quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot; +  </span><br><span class="line">                    &quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot; +  </span><br><span class="line">                    &quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot; +  </span><br><span class="line">                    &quot;return nil; &quot; +  </span><br><span class="line">                    &quot;end; &quot; +  </span><br><span class="line">                    &quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;,  </span><br><span class="line">            Collections.singletonList(getRawName()), unit.toMillis(leaseTime), getLockName(threadId));  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>

<p>可以看到Redisson中的加锁方法也是采用lua脚本</p>
<p>Redisson锁的自动定时续期是通过：<code>scheduleExpirationRenewal</code> 方法实现</p>
<p>其方法内部通过 <code>renewExpiration</code> 重置过期时间，采用TimerTask完成定时任务</p>
<p>解锁方法unlock也是采用lua脚本</p>
<p><strong>Redisson自动续期、可重入与防死锁</strong></p>
<p>实现方案与之前手动实现的Redis分布式锁类似</p>
<ol>
<li><p>如果当前代码运行时间过长，超出了锁的过期时间，但是程序仍在执行过程中，所以需要为锁续期</p>
<p>-&gt; Redisson内部提供了一个监控锁的看门狗（定时任务），它的作用是在Redisson实例被关闭前，不断地延长锁的有效期。默认情况下，看门狗每隔30秒检查一次。</p>
</li>
<li><p>如果负责储存分布式锁的Redisson节点宕机后，而这个锁恰好处于锁住状态，这时候会出现死锁。</p>
<p>-&gt; Redisson通过为锁设置超时时间（有效期），若有效期内没有定时任务为其续期，则其超过该时间就会自动解开。</p>
</li>
</ol>
<h5 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h5><p>测试自动续期代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void deduct() &#123;</span><br><span class="line">    RLock lock = this.redissonClient.getLock(&quot;lock&quot;);</span><br><span class="line">    lock.lock();</span><br><span class="line">    // 查询库存信息</span><br><span class="line">    String stock = redisTemplate.opsForValue().get(&quot;stock&quot;).toString();</span><br><span class="line">    // 判断库存是否充足</span><br><span class="line">    try &#123;</span><br><span class="line">        if (stock != null &amp;&amp; stock.length() != 0) &#123;</span><br><span class="line">            Integer st = Integer.valueOf(stock);</span><br><span class="line">            if (st &gt; 0) &#123;</span><br><span class="line">                // 扣减库存</span><br><span class="line">                redisTemplate.opsForValue().set(&quot;stock&quot;, String.valueOf(--st));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(1000);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>

<p>测试可重入代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public void deduct() &#123;</span><br><span class="line">    RLock lock = this.redissonClient.getLock(&quot;lock&quot;);</span><br><span class="line">    lock.lock();</span><br><span class="line">    // 查询库存信息</span><br><span class="line">    String stock = redisTemplate.opsForValue().get(&quot;stock&quot;).toString();</span><br><span class="line">    // 判断库存是否充足</span><br><span class="line">    try &#123;</span><br><span class="line">        if (stock != null &amp;&amp; stock.length() != 0) &#123;</span><br><span class="line">            Integer st = Integer.valueOf(stock);</span><br><span class="line">            if (st &gt; 0) &#123;</span><br><span class="line">                // 扣减库存</span><br><span class="line">                redisTemplate.opsForValue().set(&quot;stock&quot;, String.valueOf(--st));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    this.test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void test() &#123;</span><br><span class="line">    RLock lock = this.redissonClient.getLock(&quot;lock&quot;);</span><br><span class="line">    lock.lock();</span><br><span class="line">    System.out.println(&quot;测试可重入锁...&quot;);</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>

<h4 id="2-5-3-公平锁"><a href="#2-5-3-公平锁" class="headerlink" title="2.5.3 公平锁"></a>2.5.3 公平锁</h4><p>公平的体现：公平锁保证当多个Redisson客户端线程同时请求加锁时，优先分配给先发出请求的线程。</p>
<p>所有的请求线程会在一个队列中排队。如果某线程宕机后，Redisson等待5秒后继续下一个线程。</p>
<p>举个🌰：若前面有5个线程宕机，那么延迟将会是25秒。</p>
<p>顺便提一点：个人认为此处Redisson官方的<a class="link" target="_blank" rel="noopener" href="https://github.com/redisson/redisson/wiki/8.-distributed-locks-and-synchronizers">中文文档<i class="fas fa-external-link-alt"></i></a>描述略有不妥，不是<del>前面5个线程处于等待状态</del>，而是处于宕机状态</p>
<blockquote>
<p>所有请求线程会在一个队列中排队，当某个线程出现宕机时，Redisson会等待5秒后继续下一个线程，也就是说如果前面有5个线程都处于等待状态，那么后面的线程会等待至少25秒。</p>
</blockquote>
<p>对照英文版本：</p>
<blockquote>
<p>All waiting threads are queued and if some thread has died then Redisson waits its return for 5 seconds. For example, if 5 threads are died for some reason then delay will be 25 seconds.</p>
</blockquote>
<h5 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h5><ol>
<li><p>在StockController添加新的测试方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;test/fair/lock/&#123;id&#125;&quot;)</span><br><span class="line">public String testFairLock(@PathVariable(&quot;id&quot;) Long id) &#123;</span><br><span class="line">    this.stockService.testFairLock(id);</span><br><span class="line">    return &quot;hello test fair lock&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>
</li>
<li><p>在StockService添加新的测试方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void testFairLock(Long id) &#123;</span><br><span class="line">    RLock fairLock = this.redissonClient.getFairLock(&quot;fairLock&quot;);</span><br><span class="line">    fairLock.lock();</span><br><span class="line">    System.out.println(&quot;测试公平锁==================&quot; + id);</span><br><span class="line">    try &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(10);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        fairLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure></li>
</ol>
<p>启动SpringBoot，依次在浏览器请求 <code>test/fair/lock/&#123;id&#125;</code> 5次</p>
<p>可以看到最终的输出顺序和请求顺序一致，说明实现了公平锁</p>
<p><a target="_blank" rel="noopener" href="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221014004141382.png"><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221014004141382.png" alt="image-20221014004141382"></a></p>
<p>image-20221014004141382</p>
<p>如果开启了两个SpringBoot并采用nginx进行负载均衡，会出现一个请求被发送多次的情况。</p>
<p>这是因为nginx有纠错机制，当发送一个请求长时间未得到响应时，nginx会再次发送。</p>
<p>解决方案：配置nginx.conf文件，将超时时间延长。重新配置之后记得重新启动nginx。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    proxy_connect_timeout 12000</span><br><span class="line">    proxy_send_timeout 12000</span><br><span class="line">    proxy_read_timeout 12000</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://distributedLock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NGINX</span><br></pre></td></tr></table></figure>

<h4 id="2-5-4-联锁"><a href="#2-5-4-联锁" class="headerlink" title="2.5.4 联锁"></a>2.5.4 联锁</h4><p>Redisson可以将多个RLock对象关联为一个联锁。即要么同时上锁，要么同时解锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RLock lock1 = redissonInstance1.getLock(&quot;lock1&quot;);</span><br><span class="line">RLock lock2 = redissonInstance2.getLock(&quot;lock2&quot;);</span><br><span class="line">RLock lock3 = redissonInstance3.getLock(&quot;lock3&quot;);</span><br><span class="line"></span><br><span class="line">RedissonMultiLock lock = new RedissonMultiLock(lock1, lock2, lock3);</span><br><span class="line">// 同时加锁：lock1 lock2 lock3</span><br><span class="line">// 所有的锁都上锁成功才算成功。</span><br><span class="line">lock.lock();</span><br><span class="line">...</span><br><span class="line">lock.unlock();</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>

<p>但是缺点很明显：任何一个Redis宕机之后，其他所有的Redis都不可用，一般不用。</p>
<h4 id="2-5-5-红锁"><a href="#2-5-5-红锁" class="headerlink" title="2.5.5 红锁"></a>2.5.5 红锁</h4><p>红锁与联锁的不同之处在于：红锁只要大部分（过半数）节点上加锁成功就算成功。红锁也不重要</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RLock lock1 = redissonInstance1.getLock(&quot;lock1&quot;);</span><br><span class="line">RLock lock2 = redissonInstance2.getLock(&quot;lock2&quot;);</span><br><span class="line">RLock lock3 = redissonInstance3.getLock(&quot;lock3&quot;);</span><br><span class="line"></span><br><span class="line">RedissonRedLock lock = new RedissonRedLock(lock1, lock2, lock3);</span><br><span class="line">// 同时加锁：lock1 lock2 lock3</span><br><span class="line">// 红锁在大部分节点上加锁成功就算成功。</span><br><span class="line">lock.lock();</span><br><span class="line">...</span><br><span class="line">lock.unlock();</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>

<h4 id="2-5-6-读写锁"><a href="#2-5-6-读写锁" class="headerlink" title="2.5.6 读写锁"></a>2.5.6 读写锁</h4><p>读写锁特性为：读操作可以并发，但是写操作之间不可以并发，读操作与写操作不可以并发</p>
<p>举例论证读写锁存在的必要：</p>
<ul>
<li>假设读操作之间可以并发，写操作之间不可以并发。这种加锁方式保证了写操作的安全性</li>
<li>但这种方式确保不了读与写操作的安全性，因为没有限制读和写的并发，因此需要引入读写锁</li>
</ul>
<h5 id="测试代码-2"><a href="#测试代码-2" class="headerlink" title="测试代码"></a>测试代码</h5><ol>
<li><p>在StockController中新增以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;test/read/lock&quot;)</span><br><span class="line">public String testReadLock() &#123;</span><br><span class="line">    this.stockService.testReadLock();</span><br><span class="line">    return &quot;hello test read lock&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;test/write/lock&quot;)</span><br><span class="line">public String testWriteLock() &#123;</span><br><span class="line">    this.stockService.testWriteLock();</span><br><span class="line">    return &quot;hello test write lock&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>
</li>
<li><p>在StockService中新增以下代码：选择超时自动解锁的方式加锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void testReadLock() &#123;</span><br><span class="line">    RReadWriteLock rwLock = this.redissonClient.getReadWriteLock(&quot;rwLock&quot;);</span><br><span class="line">    rwLock.readLock().lock(10, TimeUnit.SECONDS);</span><br><span class="line">    System.out.println(&quot;执行写操作...&quot;);</span><br><span class="line">    //rwLock.readLock().unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void testWriteLock() &#123;</span><br><span class="line">    RReadWriteLock rwLock = this.redissonClient.getReadWriteLock(&quot;rwLock&quot;);</span><br><span class="line">    rwLock.writeLock().lock(10, TimeUnit.SECONDS);</span><br><span class="line">    System.out.println(&quot;执行写操作...&quot;);</span><br><span class="line">    //rwLock.writeLock().unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure></li>
</ol>
<p>测试对应的方法，然后查看redis中读写锁是如何存储的。</p>
<ol>
<li><p>对于读，可以存在多个读操作，mode为read</p>
<p><a target="_blank" rel="noopener" href="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221015231801864.png"><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221015231801864.png" alt="image-20221015231801864"></a></p>
</li>
<li><p>对于写，同一时间只能有一个写操作，其余均阻塞，mode为write</p>
<p><a target="_blank" rel="noopener" href="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221015231952586.png"><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221015231952586.png" alt="image-20221015231952586"></a></p>
</li>
<li><p>在读的过程中，写操作会被阻塞；在写的过程中，读操作也会被阻塞</p>
</li>
</ol>
<h4 id="2-5-7-信号量"><a href="#2-5-7-信号量" class="headerlink" title="2.5.7 信号量"></a>2.5.7 信号量</h4><p>与JUC中信号量的共同之处：都可以对请求进行限流，均适用于需求量大资源有限的情景</p>
<h5 id="JUC信号量"><a href="#JUC信号量" class="headerlink" title="JUC信号量"></a>JUC信号量</h5><p>回顾JUC中的信号量：模拟6个线程争抢有限的3个资源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Semaphore semaphore = new Semaphore(3);</span><br><span class="line">for (int i = 0; i &lt; 6; i++) &#123;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;抢到了停车位&quot;);</span><br><span class="line">            TimeUnit.SECONDS.sleep(new Random().nextInt(10));</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;停了一会儿开走了&quot;);</span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, i + &quot;号车&quot;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<p><a target="_blank" rel="noopener" href="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221015233103573.png"><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221015233103573.png" alt="image-20221015233103573"></a></p>
<p>image-20221015233103573</p>
<p>但是JUC信号量只能对单机情况下进行限流，无法做到对分布式环境进行限流</p>
<h5 id="分布式信号量"><a href="#分布式信号量" class="headerlink" title="分布式信号量"></a>分布式信号量</h5><ol>
<li><p>在StockController中添加如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;test/semaphore&quot;)</span><br><span class="line">    public String testSemaphore() &#123;</span><br><span class="line">        this.stockService.testSemaphore();</span><br><span class="line">        return &quot;hello test semaphore&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>
</li>
<li><p>在StockService中添加如下代码：通过redis记录争抢资源的顺序日志，更直观地证明分布式下的正确性</p>
<p>如果要更改semaphore可允许线程数的值，记得将redis中旧的值删去（或者起一个新的名字）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void testSemaphore() &#123;</span><br><span class="line">    RSemaphore semaphore = this.redissonClient.getSemaphore(&quot;semaphore&quot;);</span><br><span class="line">    semaphore.trySetPermits(3); // 设置限流的线程数</span><br><span class="line">    try &#123;</span><br><span class="line">        semaphore.acquire(); // 获取资源成功之后才可继续处理业务操作，否则阻塞</span><br><span class="line">        this.redisTemplate.opsForList().rightPush(&quot;log&quot;, &quot;10010获取资源，开始处理...&quot; + 	Thread.currentThread().getName());</span><br><span class="line">        TimeUnit.SECONDS.sleep(new Random().nextInt(10));</span><br><span class="line">        this.redisTemplate.opsForList().rightPush(&quot;log&quot;, &quot;10010处理完成，释放资源...&quot; + Thread.currentThread().getName());</span><br><span class="line">        semaphore.release(); // 手动释放资源</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure></li>
</ol>
<p>启动两个服务，redis中的输出日志如下：</p>
<p><a target="_blank" rel="noopener" href="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221016001007227.png"><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221016001007227.png" alt="image-20221016001007227"></a></p>
<p>image-20221016001007227</p>
<h4 id="2-5-8-倒计数器（闭锁）"><a href="#2-5-8-倒计数器（闭锁）" class="headerlink" title="2.5.8 倒计数器（闭锁）"></a>2.5.8 倒计数器（闭锁）</h4><p>一个线程(或者多个)， 等待另外N个线程完成某个事情之后才能执行</p>
<h5 id="JUC倒计数器"><a href="#JUC倒计数器" class="headerlink" title="JUC倒计数器"></a>JUC倒计数器</h5><p>示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    CountDownLatch countDownLatch = new CountDownLatch(6);</span><br><span class="line">    for (int i = 0; i &lt; 6; i++) &#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;：开始执行...&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(new Random().nextInt(5));</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;：结束执行...&quot;);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;, i + &quot;号线程&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">    throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;：其他线程均已结束，执行最后任务...&quot;);</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<p><a target="_blank" rel="noopener" href="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221016002330475.png"><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221016002330475.png" alt="image-20221016002330475"></a></p>
<p>image-20221016002330475</p>
<h5 id="分布式倒计数器"><a href="#分布式倒计数器" class="headerlink" title="分布式倒计数器"></a>分布式倒计数器</h5><ol>
<li><p>在StockController中添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;test/await&quot;)</span><br><span class="line">public String testLAwait() &#123;</span><br><span class="line">    this.stockService.testAwait();</span><br><span class="line">    return &quot;wait for other threads...&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;test/countdown&quot;)</span><br><span class="line">public String testCountDown() &#123;</span><br><span class="line">    this.stockService.testCountDown();</span><br><span class="line">    return &quot;execute...&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>
</li>
<li><p>在StockService中添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void testAwait() &#123;</span><br><span class="line">    RCountDownLatch cdl = this.redissonClient.getCountDownLatch(&quot;cdl&quot;);</span><br><span class="line">    cdl.trySetCount(6);</span><br><span class="line">    try &#123;</span><br><span class="line">        cdl.await(); // 阻塞，直到其余所有线程执行完毕</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void testCountDown() &#123;</span><br><span class="line">    RCountDownLatch cdl = this.redissonClient.getCountDownLatch(&quot;cdl&quot;);</span><br><span class="line">    cdl.countDown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-Zookeeper分布式锁"><a href="#3-Zookeeper分布式锁" class="headerlink" title="3. Zookeeper分布式锁"></a>3. Zookeeper分布式锁</h2><h3 id="3-1-Zookeeper基本指令"><a href="#3-1-Zookeeper基本指令" class="headerlink" title="3.1 Zookeeper基本指令"></a>3.1 Zookeeper基本指令</h3><ol>
<li><p>查看某个目录下的子节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls /</span><br><span class="line">ls /node</span><br><span class="line"></span><br><span class="line">BASH</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建节点 create命令</p>
<p>在根目录创建 <code>node</code> 节点，其内容为 “abc”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create /node &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">CRMSH</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新节点内容 set命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set /node &quot;aaa&quot;</span><br><span class="line"></span><br><span class="line">BASH</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取节点数据 get命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get /node</span><br><span class="line">get -s /node 获取详细内容</span><br><span class="line"></span><br><span class="line">CRMSH</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除节点 delete命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delete /node</span><br><span class="line"></span><br><span class="line">CRMSH</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-2-ZNode节点类型"><a href="#3-2-ZNode节点类型" class="headerlink" title="3.2 ZNode节点类型"></a>3.2 ZNode节点类型</h3><p>永久节点：一旦节点被创建就一直存在，及时Zookeeper宕机也不会被删除，只能手动将其删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create /node</span><br><span class="line"></span><br><span class="line">CRMSH</span><br></pre></td></tr></table></figure>

<p>临时节点：临时节点的生命周期与客户端会话相绑定，会话消失则节点也会随之消失。并且临时节点只能做叶子节点，不能创建子节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create -e /node</span><br><span class="line"></span><br><span class="line">CRMSH</span><br></pre></td></tr></table></figure>

<p>永久序列化节点：具有永久节点的特性，而且在创建该类节点时，Zookeeper会在节点名称后加入顺序编号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create -s /node</span><br><span class="line"></span><br><span class="line">CRMSH</span><br></pre></td></tr></table></figure>

<p>临时序列化节点：具有临时节点的特性，而且在创建该类节点时，Zookeeper会在节点名称后加入顺序编号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create -e -s /node</span><br><span class="line"></span><br><span class="line">CRMSH</span><br></pre></td></tr></table></figure>

<h3 id="3-3-事件监听"><a href="#3-3-事件监听" class="headerlink" title="3.3 事件监听"></a>3.3 事件监听</h3><p>Watcher事件监听器：监听是一次性的，一个监听指令只能监听到一次变化</p>
<p>同时开启两个zk客户端，一个客户端用于监听，另一个客户端用于操作节点</p>
<ol>
<li><p>节点创建：NodeCreated</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stat -w /xx</span><br><span class="line"></span><br><span class="line">BASH</span><br></pre></td></tr></table></figure>
</li>
<li><p>节点删除：NodeDeleted</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stat -w /xx</span><br><span class="line"></span><br><span class="line">BASH</span><br></pre></td></tr></table></figure>
</li>
<li><p>节点数据变化：NodeDataChanged</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get -w /xx</span><br><span class="line"></span><br><span class="line">ROUTEROS</span><br></pre></td></tr></table></figure>
</li>
<li><p>子节点变化：NodeChildrenChanged</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 监听xx下的子节点变化</span><br><span class="line">ls -w /xx </span><br><span class="line"></span><br><span class="line">BASH</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-4-Java客户端"><a href="#3-4-Java客户端" class="headerlink" title="3.4 Java客户端"></a>3.4 Java客户端</h3><h4 id="3-4-1-案例搭建"><a href="#3-4-1-案例搭建" class="headerlink" title="3.4.1 案例搭建"></a>3.4.1 案例搭建</h4><ol>
<li><p>引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.7.0&lt;/version&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">XML</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建ZkTest类，在main方法编写如下代码</p>
<ul>
<li>Zookeeper构造方法中需要填的参数<ul>
<li>ip地址与端口号port</li>
<li>超时时间</li>
<li>Watcher事件监听器匿名类</li>
</ul>
</li>
<li>用CountDownLatch，使Zookeeper在获取到链接之后才进行之后的操作</li>
<li>Watcher事件监听中：监听获取链接与关闭链接两个事件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ZooKeeper zooKeeper = null;</span><br><span class="line">CountDownLatch countDownLatch = new CountDownLatch(1);</span><br><span class="line">try &#123;</span><br><span class="line">    zooKeeper = new ZooKeeper(&quot;127.0.0.1:2181&quot;, 30000, new Watcher() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void process(WatchedEvent watchedEvent) &#123;</span><br><span class="line">            Event.KeeperState state = watchedEvent.getState();</span><br><span class="line">            if (Event.KeeperState.SyncConnected.equals(state)) &#123;</span><br><span class="line">                System.out.println(&quot;获取链接：&quot; + watchedEvent);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125; else if (Event.KeeperState.Closed.equals(state)) &#123;</span><br><span class="line">                System.out.println(&quot;关闭链接：&quot; + watchedEvent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    System.out.println(&quot;执行操作...&quot;);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    throw new RuntimeException(e);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    if (zooKeeper != null) &#123;</span><br><span class="line">        zooKeeper.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">获取链接：WatchedEvent state:SyncConnected type:None path:null</span><br><span class="line">执行操作...</span><br><span class="line">关闭链接：WatchedEvent state:Closed type:None path:null</span><br><span class="line"></span><br><span class="line">PF</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="3-4-2-操作节点"><a href="#3-4-2-操作节点" class="headerlink" title="3.4.2 操作节点"></a>3.4.2 操作节点</h4><ol>
<li><p>创建节点：第一个参数为节点名路径，第二参数为节点内容，第三个参数为节点权限，第四个参数为节点类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 永久节点</span><br><span class="line">zooKeeper.create(&quot;ltyzzz/test1&quot;, &quot;hello zookeeper&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">// 临时节点</span><br><span class="line">zooKeeper.create(&quot;ltyzzz/test2&quot;, &quot;hello zookeeper&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line">// 永久序列化节点</span><br><span class="line">zooKeeper.create(&quot;ltyzzz/test3&quot;, &quot;hello zookeeper&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);</span><br><span class="line">// 临时序列化节点 </span><br><span class="line">zooKeeper.create(&quot;ltyzzz/test3&quot;, &quot;hello zookeeper&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询节点</p>
<ol>
<li><p>判断节点是否存在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stat exists = zooKeeper.exists(&quot;/ltyzzz&quot;, false);</span><br><span class="line">if (exists != null) &#123;</span><br><span class="line">    System.out.println(&quot;当前节点存在&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;当前节点不存在&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取当前节点中的数据内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">byte[] data = zooKeeper.getData(&quot;/ltyzzz&quot;, false, exists);</span><br><span class="line">System.out.println(&quot;当前节点内容：&quot; + new String(data));</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取当前节点的子节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; children = zooKeeper.getChildren(&quot;/ltyzzz&quot;, false);</span><br><span class="line">System.out.println(&quot;当前节点的子节点：&quot; + children);</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>更新节点</p>
<ul>
<li>其中第三个参数为版本号。该版本号必须和当前节点版本号一致，否则更新失败（乐观锁）</li>
<li>可以将其指定为-1，表示不关心版本号</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zooKeeper.setData(&quot;/ltyzzz&quot;, &quot;zzz...&quot;.getBytes(), exists.getVersion());</span><br><span class="line">zooKeeper.setData(&quot;/ltyzzz&quot;, &quot;zzz...&quot;.getBytes(), -1); // 不关心版本号</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zooKeeper.delete(&quot;/ltyzzz/test1&quot;, -1); // 不关心版本号</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="3-4-3-节点监听事件"><a href="#3-4-3-节点监听事件" class="headerlink" title="3.4.3 节点监听事件"></a>3.4.3 节点监听事件</h4><p>每一个操作节点的方法中均有一个watch参数，为boolean类型。</p>
<p>watch为true时，代表启动节点监听事件</p>
<h3 id="3-5-实现Zookeeper分布式锁"><a href="#3-5-实现Zookeeper分布式锁" class="headerlink" title="3.5 实现Zookeeper分布式锁"></a>3.5 实现Zookeeper分布式锁</h3><p>独占排他：ZNode节点不可重复</p>
<h4 id="3-5-1-自旋锁版本"><a href="#3-5-1-自旋锁版本" class="headerlink" title="3.5.1 自旋锁版本"></a>3.5.1 自旋锁版本</h4><ol>
<li><p>创建ZkClient，用于初始化时获取Zk链接与结束时释放Zk链接</p>
<ul>
<li>添加@Component注解，交给Spring容器管理，SpringBoot启动时会执行初始化操作</li>
<li>@PostConstruct：执行完ZkClient构造方法之后，获取Zookeeper链接</li>
<li>@PreDestroy：在ZkClient销毁之前，释放Zookeeper链接</li>
<li>getLock：用于创建锁对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ZkClient &#123;</span><br><span class="line"></span><br><span class="line">    ZooKeeper zooKeeper = null;</span><br><span class="line">    </span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        // 获取Zk链接</span><br><span class="line">        CountDownLatch countDownLatch = new CountDownLatch(1);</span><br><span class="line">        try &#123;</span><br><span class="line">            zooKeeper = new ZooKeeper(&quot;127.0.0.1:2181&quot;, 30000, new Watcher() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void process(WatchedEvent watchedEvent) &#123;</span><br><span class="line">                    Event.KeeperState state = watchedEvent.getState();</span><br><span class="line">                    if (Event.KeeperState.SyncConnected.equals(state)) &#123;</span><br><span class="line">                        System.out.println(&quot;获取链接：&quot; + watchedEvent);</span><br><span class="line">                        countDownLatch.countDown();</span><br><span class="line">                    &#125; else if (Event.KeeperState.Closed.equals(state)) &#123;</span><br><span class="line">                        System.out.println(&quot;关闭链接：&quot; + watchedEvent);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PreDestroy</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        // 释放Zk链接</span><br><span class="line">        if (zooKeeper != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                zooKeeper.close();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ZkDistributedLock getLock(String lockName) &#123;</span><br><span class="line">        return new ZkDistributedLock(zooKeeper, lockName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建ZkDistributedLock类，用于实现锁</p>
<ul>
<li>所有的锁都将创建在 <code>/locks</code> 目录下，所以在构造方法中，需要先判断有没有该目录，没有的话则需要提前创建</li>
<li>注意：<code>/locks</code> 为永久节点，而创建出来的锁为临时节点，这是为了防止服务器宕机造成的死锁问题，而设置为临时节点的话，服务器宕机之后，临时节点也会随之被删除。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">public class ZkDistributedLock implements Lock &#123;</span><br><span class="line"></span><br><span class="line">    private String lockName;</span><br><span class="line">    private ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    private static final String ROOT_PATH = &quot;/locks&quot;;</span><br><span class="line"></span><br><span class="line">    public ZkDistributedLock(ZooKeeper zooKeeper, String lockName) &#123;</span><br><span class="line">        this.zooKeeper = zooKeeper;</span><br><span class="line">        this.lockName = lockName;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (zooKeeper.exists(ROOT_PATH, false) == null) &#123;</span><br><span class="line">                zooKeeper.create(ROOT_PATH, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (KeeperException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        // 创建ZNode节点</span><br><span class="line">        tryLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            zooKeeper.create(ROOT_PATH + &quot;/&quot; + lockName, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(80);</span><br><span class="line">                tryLock();</span><br><span class="line">            &#125; catch (InterruptedException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        // 删除ZNode节点</span><br><span class="line">        try &#123;</span><br><span class="line">            this.zooKeeper.delete(ROOT_PATH + &quot;/&quot; + lockName, -1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125; catch (KeeperException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Condition newCondition() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>
</li>
<li><p>在StockService中注入ZkClient对象，并修改deduct方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private ZkClient zkClient;</span><br><span class="line"></span><br><span class="line">public void deduct() &#123;</span><br><span class="line">    ZkDistributedLock lock = zkClient.getLock(&quot;lock&quot;);</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        String stock = redisTemplate.opsForValue().get(&quot;stock&quot;).toString();</span><br><span class="line">        if (stock != null &amp;&amp; stock.length() != 0) &#123;</span><br><span class="line">            Integer st = Integer.valueOf(stock);</span><br><span class="line">            if (st &gt; 0) &#123;</span><br><span class="line">                // 扣减库存</span><br><span class="line">                redisTemplate.opsForValue().set(&quot;stock&quot;, String.valueOf(--st));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="3-5-2-阻塞公平锁版本"><a href="#3-5-2-阻塞公平锁版本" class="headerlink" title="3.5.2 阻塞公平锁版本"></a>3.5.2 阻塞公平锁版本</h4><p>利用临时序列化节点与监听机制实现</p>
<ol>
<li><p>临时序列化节点在创建节点时，节点的名称后会追加序列号。</p>
<p>给每一个获取锁的请求都创建一个临时序列化节点，越先尝试获取锁的节点，其序列号越小，优先级越高，满足公平锁的定义</p>
<ol>
<li>获取当前节点的前驱节点<ul>
<li>若前驱节点为空，则获取锁成功，否则监听前驱节点</li>
</ul>
</li>
<li>获取锁成功后执行业务操作，最后释放当前节点的锁</li>
</ol>
</li>
<li><p>后创建的节点监听它之前的一个节点，如果监听到它的前驱节点被删除，则相当于获取到锁；否则阻塞</p>
<p>（类似于AQS中同步队列的定义）</p>
</li>
</ol>
<p>改造之前的代码：更改tryLock与unlock代码</p>
<p>注意：</p>
<ol>
<li>Zookeeper调用create方法后，会返回其全路径，这里将其作为了成员变量，方便解锁时删除</li>
<li>路径中加上了“-”，方便之后获取每个节点的序列号</li>
<li>通过编写getPreNode方法，获取当前节点的前驱节点</li>
<li>通过CountDownLatch实现阻塞功能</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean tryLock() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        currentNodePath = zooKeeper.create(ROOT_PATH + &quot;/&quot; + lockName + &quot;-&quot;, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">        // 获取前驱节点：若前驱节点为空，则获取锁成功，否则监听该节点</span><br><span class="line">        String preNode = this.getPreNode();</span><br><span class="line">        if (preNode != null) &#123;</span><br><span class="line">            // 利用闭锁实现阻塞</span><br><span class="line">            CountDownLatch countDownLatch = new CountDownLatch(1);</span><br><span class="line">            // 因为获取前驱节点操作不具备原子性，需要再次判断zk中的前驱节点是否存在</span><br><span class="line">            if (zooKeeper.exists(ROOT_PATH + &quot;/&quot; + preNode, new Watcher() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void process(WatchedEvent watchedEvent) &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;) == null) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private String getPreNode() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 获取根节点下的所有节点</span><br><span class="line">        List&lt;String&gt; children = this.zooKeeper.getChildren(ROOT_PATH, false);</span><br><span class="line">        if (CollectionUtils.isEmpty(children)) &#123;</span><br><span class="line">            throw new IllegalMonitorStateException(&quot;非法操作&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取根节点中对应于当前锁的所有节点</span><br><span class="line">        List&lt;String&gt; nodes = children.stream().filter(node -&gt; StringUtils.startsWith(node, lockName + &quot;-&quot;)).collect(Collectors.toList());</span><br><span class="line">        if (CollectionUtils.isEmpty(nodes)) &#123;</span><br><span class="line">            throw new IllegalMonitorStateException(&quot;非法操作&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 按照序列号排序</span><br><span class="line">        Collections.sort(nodes);</span><br><span class="line">        String currentNode = StringUtils.substringAfterLast(currentNodePath, &quot;/&quot;);</span><br><span class="line">        // 获取当前节点对应的下标</span><br><span class="line">        int index = Collections.binarySearch(nodes, currentNode);</span><br><span class="line">        if (index &lt; 0) &#123;</span><br><span class="line">            throw new IllegalMonitorStateException(&quot;非法操作&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (index &gt; 0) &#123;</span><br><span class="line">            // 返回当前节点的前驱节点</span><br><span class="line">            return nodes.get(index - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        throw new IllegalMonitorStateException(&quot;非法操作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void unlock() &#123;</span><br><span class="line">    // 删除ZNode节点</span><br><span class="line">    try &#123;</span><br><span class="line">        this.zooKeeper.delete(currentNodePath, -1);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125; catch (KeeperException e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>

<h4 id="3-5-3-实现可重入功能"><a href="#3-5-3-实现可重入功能" class="headerlink" title="3.5.3 实现可重入功能"></a>3.5.3 实现可重入功能</h4><p>通过ThreadLocal这一线程局部变量，记录重入次数</p>
<p>改造代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean tryLock() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 判断thread local中是否已经有锁，有锁则直接重入+1</span><br><span class="line">        Integer flag = THREAD_LOCAL.get();</span><br><span class="line">        if (flag != null &amp;&amp; flag &gt; 0) &#123;</span><br><span class="line">            THREAD_LOCAL.set(flag + 1);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        currentNodePath = zooKeeper.create(ROOT_PATH + &quot;/&quot; + lockName + &quot;-&quot;, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">        // 获取前驱节点：若前驱节点为空，则获取锁成功，否则监听该节点</span><br><span class="line">        String preNode = this.getPreNode();</span><br><span class="line">        if (preNode != null) &#123;</span><br><span class="line">            // 利用闭锁实现阻塞</span><br><span class="line">            CountDownLatch countDownLatch = new CountDownLatch(1);</span><br><span class="line">            // 因为获取前驱节点操作不具备原子性，需要再次判断zk中的前驱节点是否存在</span><br><span class="line">            if (zooKeeper.exists(ROOT_PATH + &quot;/&quot; + preNode, new Watcher() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void process(WatchedEvent watchedEvent) &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;) == null) &#123;</span><br><span class="line">                THREAD_LOCAL.set(1);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125;</span><br><span class="line">        THREAD_LOCAL.set(1);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void unlock() &#123;</span><br><span class="line">    // 删除ZNode节点</span><br><span class="line">    try &#123;</span><br><span class="line">        THREAD_LOCAL.set(THREAD_LOCAL.get() - 1);</span><br><span class="line">        // 减为0则删除</span><br><span class="line">        if (THREAD_LOCAL.get() == 0) &#123;</span><br><span class="line">            this.zooKeeper.delete(currentNodePath, -1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125; catch (KeeperException e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>

<h3 id="3-6-Curator"><a href="#3-6-Curator" class="headerlink" title="3.6 Curator"></a>3.6 Curator</h3><p>Curator由一系列的模块构成，对于一般开发者而言，常用的是curator-framework和curator-recipes：</p>
<ul>
<li>curator-framework：提供了常见的zk相关的底层操作</li>
<li>curator-recipes：提供了一些zk的典型使用场景的参考</li>
</ul>
<ol>
<li><p>引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.3.0&lt;/version&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.3.0&lt;/version&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.4.14&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">XML</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置Curator：新建CuratorConfig配置类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class CuratorConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public CuratorFramework curatorFramework() &#123;</span><br><span class="line">        // 初始化重试策略，使用的指数补偿策略</span><br><span class="line">        RetryPolicy retry = new ExponentialBackoffRetry(10000, 3); // 设置初始间隔时间与重试次数</span><br><span class="line">        // 初始化curatork客户端</span><br><span class="line">        CuratorFramework client = CuratorFrameworkFactory.newClient(&quot;127.0.0.1:2181&quot;, retry);</span><br><span class="line">        client.start(); // 手动启动，否则很多方法功能不能够工作</span><br><span class="line">        return client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="3-6-1-InterProcessMutex"><a href="#3-6-1-InterProcessMutex" class="headerlink" title="3.6.1 InterProcessMutex"></a>3.6.1 InterProcessMutex</h4><p>与ReentrantLock类似，拥有可重入的特性。</p>
<h5 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h5><p>注入CuratorFramework，修改StockService中的deduct方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private CuratorFramework curatorFramework;</span><br><span class="line"></span><br><span class="line">public void deduct() &#123;</span><br><span class="line">    InterProcessMutex mutex = new InterProcessMutex(curatorFramework, &quot;/curator/locks&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        mutex.acquire();</span><br><span class="line">        String stock = redisTemplate.opsForValue().get(&quot;stock&quot;).toString();</span><br><span class="line">        if (stock != null &amp;&amp; stock.length() != 0) &#123;</span><br><span class="line">            Integer st = Integer.valueOf(stock);</span><br><span class="line">            if (st &gt; 0) &#123;</span><br><span class="line">                // 扣减库存</span><br><span class="line">                redisTemplate.opsForValue().set(&quot;stock&quot;, String.valueOf(--st));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        this.testSub(mutex); // 测试可重入</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            mutex.release();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void testSub(InterProcessMutex mutex) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        mutex.acquire();</span><br><span class="line">        System.out.println(&quot;测试可重入锁。。。。&quot;);</span><br><span class="line">        mutex.release();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>

<h5 id="底层原理-1"><a href="#底层原理-1" class="headerlink" title="底层原理"></a>底层原理</h5><p>InterProcessMutex初始化原理</p>
<ol>
<li><p>首先调用如下构造方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 将传入的参数再传入到下一个构造方法中</span><br><span class="line">public InterProcessMutex(CuratorFramework client, String path)</span><br><span class="line">&#123;</span><br><span class="line">    this(client, path, new StandardLockInternalsDriver());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>
</li>
<li><p>进一步调用构造方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// this中的第一个参数为传进来的client，第二个参数为传进来的path</span><br><span class="line">// 第三个参数为常量LOCK_NAME:&quot;lock-&quot;</span><br><span class="line">// 第四个参数为驱动Driver：new StandardLockInternalsDriver()</span><br><span class="line">public InterProcessMutex(CuratorFramework client, String path, LockInternalsDriver driver)</span><br><span class="line">&#123;</span><br><span class="line">    // 1为租约：maxLeases</span><br><span class="line">    this(client, path, LOCK_NAME, 1, driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>
</li>
<li><p>再进一步调用构造方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InterProcessMutex(CuratorFramework client, String path, String lockName, int maxLeases, LockInternalsDriver driver)</span><br><span class="line">&#123;</span><br><span class="line">    // 这是对传进来的path参数做校验</span><br><span class="line">    basePath = PathUtils.validatePath(path);</span><br><span class="line">    // LockInternals实例化很关键，之后的加锁与解锁方法都需要用到这个类</span><br><span class="line">    internals = new LockInternals(client, driver, path, lockName, maxLeases);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建LockInternals对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LockInternals(CuratorFramework client, LockInternalsDriver driver, String path, String lockName, int maxLeases)</span><br><span class="line">&#123;</span><br><span class="line">    this.driver = driver;</span><br><span class="line">    this.lockName = lockName;</span><br><span class="line">    this.maxLeases = maxLeases;</span><br><span class="line"></span><br><span class="line">    this.client = client.newWatcherRemoveCuratorFramework();</span><br><span class="line">    // 再次校验path参数</span><br><span class="line">    this.basePath = PathUtils.validatePath(path);</span><br><span class="line">    // 将路径与锁名称进行拼接</span><br><span class="line">    this.path = ZKPaths.makePath(path, lockName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure></li>
</ol>
<p>加锁原理</p>
<ol>
<li><p>执行 <code>mutex.acquire()</code> 方法时，内部调用acquire方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void acquire() throws Exception</span><br><span class="line">&#123;</span><br><span class="line">    if ( !internalLock(-1, null) )</span><br><span class="line">    &#123;</span><br><span class="line">        throw new IOException(&quot;Lost connection while trying to acquire lock: &quot; + basePath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>
</li>
<li><p>内部又调用了internalLock方法：直接看注释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private boolean internalLock(long time, TimeUnit unit) throws Exception</span><br><span class="line">&#123;</span><br><span class="line">    // 获取当前线程</span><br><span class="line">    Thread currentThread = Thread.currentThread();</span><br><span class="line">	// 通过当前线程获取localData对象</span><br><span class="line">    LockData lockData = threadData.get(currentThread);</span><br><span class="line">    // 如果lockData不为null，说明发生了重入</span><br><span class="line">    if ( lockData != null )</span><br><span class="line">    &#123;</span><br><span class="line">        // 将重入次数加1，然后直接返回即可</span><br><span class="line">        lockData.lockCount.incrementAndGet();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">	// lockData为null，说明是获取新的锁</span><br><span class="line">    String lockPath = internals.attemptLock(time, unit, getLockNodeBytes());</span><br><span class="line">    if ( lockPath != null )</span><br><span class="line">    &#123;</span><br><span class="line">        // 创建一个新的lockData，并将当前线程的lockData记录到哈希表中</span><br><span class="line">        LockData newLockData = new LockData(currentThread, lockPath);</span><br><span class="line">        threadData.put(currentThread, newLockData);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>

<p>其中threadData是一个ConcurrentMap，key为Thread，值为LockData。记录了重入信息。</p>
<p>LockData是一个内部类</p>
<p>threadData与LockData属性如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private final ConcurrentMap&lt;Thread, LockData&gt; threadData = Maps.newConcurrentMap();</span><br><span class="line">private static class LockData</span><br><span class="line">&#123;</span><br><span class="line">    final Thread owningThread; // 所属线程</span><br><span class="line">    final String lockPath; // 锁路径</span><br><span class="line">    final AtomicInteger lockCount = new AtomicInteger(1); // 重入次数</span><br><span class="line"></span><br><span class="line">    private LockData(Thread owningThread, String lockPath)</span><br><span class="line">    &#123;</span><br><span class="line">        this.owningThread = owningThread;</span><br><span class="line">        this.lockPath = lockPath;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取新的锁时，会调用 <code>internals.attemptLock()</code> 方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">String attemptLock(long time, TimeUnit unit, byte[] lockNodeBytes) throws Exception</span><br><span class="line">&#123;</span><br><span class="line">    final long      startMillis = System.currentTimeMillis();</span><br><span class="line">    final Long      millisToWait = (unit != null) ? unit.toMillis(time) : null;</span><br><span class="line">    final byte[]    localLockNodeBytes = (revocable.get() != null) ? new byte[0] : lockNodeBytes;</span><br><span class="line">    int             retryCount = 0;</span><br><span class="line">    String          ourPath = null;</span><br><span class="line">    boolean         hasTheLock = false;</span><br><span class="line">    boolean         isDone = false;</span><br><span class="line">    // 死循环重复尝试获取锁</span><br><span class="line">    while ( !isDone )</span><br><span class="line">    &#123;</span><br><span class="line">        isDone = true;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            // 创建一个当前锁的节点（临时序列化节点），并获取当前锁的全路径</span><br><span class="line">            ourPath = driver.createsTheLock(client, path, localLockNodeBytes);</span><br><span class="line">            hasTheLock = internalLockLoop(startMillis, millisToWait, ourPath);</span><br><span class="line">        &#125;</span><br><span class="line">        catch ( KeeperException.NoNodeException e )</span><br><span class="line">        &#123;</span><br><span class="line">            if ( client.getZookeeperClient().getRetryPolicy().allowRetry(retryCount++, System.currentTimeMillis() - startMillis, RetryLoop.getDefaultRetrySleeper()) )</span><br><span class="line">            &#123;</span><br><span class="line">                isDone = false;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                throw e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( hasTheLock )</span><br><span class="line">    &#123;</span><br><span class="line">        return ourPath;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="3-6-2-其它锁"><a href="#3-6-2-其它锁" class="headerlink" title="3.6.2 其它锁"></a>3.6.2 其它锁</h4><ol>
<li><p>InterceProcessSemaphoreMutex：不可重入锁，其它与InterProcessMutex一致</p>
</li>
<li><p>InterProcessReadWriteMutex：读写锁 -&gt; 读读可并发，读写不可并发，写写不可并发</p>
<p>有一个不同于Redisson分布式读写锁的特点：写锁在释放之前仍会阻塞请求线程，而读锁不会</p>
<ol>
<li><p>在StockController中加入如下两个方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;test/zk/read/lock&quot;)</span><br><span class="line">public String testZkReadLock() &#123;</span><br><span class="line">    this.stockService.testZkReadLock();</span><br><span class="line">    return &quot;hello test Zk read lock&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;test/zk/write/lock&quot;)</span><br><span class="line">public String testZkWriteLock() &#123;</span><br><span class="line">    this.stockService.testZkWriteLock();</span><br><span class="line">    return &quot;hello test Zk write lock&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>
</li>
<li><p>在StockService中加入如下两个方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void testZkReadLock() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        InterProcessReadWriteLock lock = new InterProcessReadWriteLock(curatorFramework, &quot;/curator/rwLock&quot;);</span><br><span class="line">        lock.readLock().acquire(10, TimeUnit.SECONDS);</span><br><span class="line">        //lock.readLock().release();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void testZkWriteLock() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        InterProcessReadWriteLock lock = new InterProcessReadWriteLock(curatorFramework, &quot;/curator/rwLock&quot;);</span><br><span class="line">        lock.writeLock().acquire(10, TimeUnit.SECONDS);</span><br><span class="line">        //lock.readLock().release();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>InterProcessMultiLock：联锁。所有的锁都加锁成功才算成功，否则加锁失败</p>
</li>
<li><p>InterProcessSemaphoreV2：信号量。限流作用</p>
<p>修改StockService中的testSemaphore方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void testSemaphore() &#123;</span><br><span class="line">    InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(curatorFramework, &quot;/curator/locks&quot;, 5);</span><br><span class="line">    try &#123;</span><br><span class="line">        Lease lease = semaphore.acquire();</span><br><span class="line">        this.redisTemplate.opsForList().rightPush(&quot;log&quot;, &quot;10086获取资源，开始处理...&quot; + Thread.currentThread().getName());</span><br><span class="line">        TimeUnit.SECONDS.sleep(new Random().nextInt(10));</span><br><span class="line">        this.redisTemplate.opsForList().rightPush(&quot;log&quot;, &quot;10086处理完成，释放资源...&quot; + Thread.currentThread().getName());</span><br><span class="line">        semaphore.returnLease(lease);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>
</li>
<li><p>共享计数器：类似于CountDownLatch</p>
<p>Curator提供了两个实现类：SharedCount与DistributedAtomicNumber</p>
<p>SharedCount实现如下：</p>
<ol>
<li><p>StockController中新增如下方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;test/sharedCount&quot;)</span><br><span class="line">public String testSharedCount() &#123;</span><br><span class="line">    this.stockService.testSharedCount();</span><br><span class="line">    return &quot;hello test SharedCount&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>
</li>
<li><p>StockService中新增如下方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void testSharedCount() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        SharedCount sharedCount = new SharedCount(curatorFramework, &quot;/curator/sharedcount&quot;, 100);</span><br><span class="line">        sharedCount.start();</span><br><span class="line">        int count = sharedCount.getCount();</span><br><span class="line">        int random = new Random().nextInt(1000);</span><br><span class="line">        sharedCount.setCount(random);</span><br><span class="line">        System.out.println(&quot;共享计数器初始值为：&quot; + count + &quot;, 现在值为：&quot; + random);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="4-MySQL分布式锁"><a href="#4-MySQL分布式锁" class="headerlink" title="4. MySQL分布式锁"></a>4. MySQL分布式锁</h2><h3 id="4-1-实现方案"><a href="#4-1-实现方案" class="headerlink" title="4.1 实现方案"></a>4.1 实现方案</h3><p>数据库准备工作</p>
<ol>
<li><p>新建一张表tb_lock，两个字段分别为：id、lock_name</p>
<p><a target="_blank" rel="noopener" href="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221020232747128.png"><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221020232747128.png" alt="image-20221020232747128"></a></p>
</li>
<li><p>为lock_name设置索引，索引类型为unique唯一键索引</p>
<p><a target="_blank" rel="noopener" href="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221020232946531.png"><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221020232946531.png" alt="image-20221020232946531"></a></p>
</li>
</ol>
<p>思路为：</p>
<ol>
<li><p>加锁时执行如下SQL语句，若执行成功则代表加锁成功</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO tb_lock(lock_name) values (&#x27;lock&#x27;)</span><br><span class="line"></span><br><span class="line">N1QL</span><br></pre></td></tr></table></figure>
</li>
<li><p>释放锁时，通过delete删除对应的锁记录</p>
</li>
</ol>
<p>代码实现：</p>
<ol>
<li><p>在pojo包下新建Lock类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@TableName(&quot;tb_lock&quot;)</span><br><span class="line">public class Lock &#123;</span><br><span class="line"></span><br><span class="line">    private Long id;</span><br><span class="line">    private String lockName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>
</li>
<li><p>在mapper包下创建LockMapper接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface LockMapper extends BaseMapper&lt;Lock&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改StockService中的deduct方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public void deduct() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Lock lock = new Lock();</span><br><span class="line">        lock.setLockName(&quot;lock&quot;);</span><br><span class="line">        this.lockMapper.insert(lock);</span><br><span class="line">        String stock = redisTemplate.opsForValue().get(&quot;stock&quot;).toString();</span><br><span class="line">        if (stock != null &amp;&amp; stock.length() != 0) &#123;</span><br><span class="line">            Integer st = Integer.valueOf(stock);</span><br><span class="line">            if (st &gt; 0) &#123;</span><br><span class="line">                // 扣减库存</span><br><span class="line">                redisTemplate.opsForValue().set(&quot;stock&quot;, String.valueOf(--st));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        this.lockMapper.deleteById(lock.getId());</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(50);</span><br><span class="line">            this.deduct();</span><br><span class="line">        &#125; catch (InterruptedException ex) &#123;</span><br><span class="line">            throw new RuntimeException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure></li>
</ol>
<p>经过JMeter测试之后发现，基于MySQL实现的分布式锁虽然实现了并发下将库存减为0的功能，但是性能极差。</p>
<h3 id="4-2-小结"><a href="#4-2-小结" class="headerlink" title="4.2 小结"></a>4.2 小结</h3><ol>
<li><p>独占排他互斥使用：采用唯一键索引实现</p>
</li>
<li><p>防死锁：客户端程序获取到锁之后，客户端服务器宕机造成死锁。</p>
<ul>
<li><p>解决方案：为tb_lock表添加获取锁时间字段lock_time，根据系统当前时间进行判断是否超时。</p>
<p>需要采用额外的定时器去检查获取锁的系统时间与当前系统时间的差值是否超过某一阈值</p>
</li>
</ul>
</li>
<li><p>可重入：</p>
<ul>
<li>解决方案：为tb_lock表添加server_id字段，代表对应的服务器；添加thread_id字段，代表对应服务器的线程；添加count字段，代表重入次数。</li>
</ul>
</li>
<li><p>防误删：借助于id的唯一性防误删</p>
</li>
<li><p>原子性：单个写操作，还可借助MySQL悲观锁</p>
</li>
<li><p>自动续期：使用服务内的定时器重置获取锁的系统时间</p>
</li>
<li><p>单机故障：搭建MySQL主备服务器</p>
</li>
<li><p>集群下锁机制失效：难解决</p>
</li>
<li><p>阻塞锁：难实现</p>
</li>
</ol>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><ol>
<li>简易程度：MySQL最简单，其次Redis，Zookeeper最难</li>
<li>性能：Redis &gt; Zookeeper &gt; MySQL</li>
<li>可靠性：Zookeeper &gt; Redis &#x3D; MySQL</li>
</ol>
<ul>
<li>如果要求不高、只实现独占排他、不要求可靠性与性能，选择MySQL</li>
<li>如果追求性能，选择Redis</li>
<li>如果追求可靠性，选择Zookeeper</li>
</ul>

            </div>

            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                               rel="prev"
                               href="/2023/07/01/%E8%87%AA%E5%B7%B1%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AARPC/"
                            >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                                <span class="title flex-center">
                                <span class="post-nav-title-item text-ellipsis">自己如何实现一个RPC</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                               rel="next"
                               href="/2023/07/01/%E5%BC%80%E6%BA%90%E7%AC%AC%E4%B8%80%E6%AD%A5/"
                            >
                            <span class="title flex-center">
                                <span class="post-nav-title-item text-ellipsis">开源第一步</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                                <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                            </a>
                        </div>
                    
                </div>
            

            
                






            
        </div>

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="border-box website-info-box default">
        
            <div class="copyright-info info-item default">
                &copy;&nbsp;<span>2020</span>&nbsp;-&nbsp;2023
                
                    &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">小梦同学</a>
                
            </div>

            <div class="theme-info info-item default">
                由&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.7.3</a>
            </div>

            

            
        

        <div class="count-item info-item default">
            

            

            
        </div>
    </div>
</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools right-toc">
            <div class="post-tools-container border-box">
    <ul class="tools-list border-box">
        <!-- PC TOC show toggle -->
        

        <!-- PC go comment -->
        
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        

        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    

    <!-- tablet toc -->
    
</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>










<div class="post-scripts">
    
        
<script src="/js/post-helper.js"></script>

        
        
    
    
    
</div>




</body>
</html>
